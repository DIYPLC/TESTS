FUNCTION_BLOCK "ExecuteTemplate"
TITLE = Execute Template
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : '(department/personInCharge/contact)'
FAMILY : '(family)'
//Template for an FB with Execute / Busy / Done handling based on PLCopen standard "Function Blocks for Motion Control" V2.1
   VAR_INPUT 
      execute : Bool;   // Rising edge starts action once
   END_VAR

   VAR_OUTPUT 
      done { ExternalWritable := 'False'} : Bool;   // TRUE: Commanded functionality has been completed successfully
      busy { ExternalWritable := 'False'} : Bool;   // TRUE: FB is not finished; new output values can be expected
      commandAborted { ExternalWritable := 'False'} : Bool;   // TRUE: Commanded functionality has been aborted by another command  (optional)
      error { ExternalWritable := 'False'} : Bool;   // TRUE: An error occurred during the execution of the functionality
      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;   // 16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error identification
      diagnostics { ExternalWritable := 'False'} : "typeDiagnostics";   // Diagnostics information of FB
   END_VAR

   VAR 
      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Internal function flags
         executePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Previous value of 'execute' input for edge detection
         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'done'
         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'busy'
         commandAborted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'commandAborted'
         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'error'
         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "typeDiagnostics" := (#STATUS_NO_CALL, (), ());   // Diagnostics information of FB
         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "typeDiagnostics";   // Empty diagnostics information (for initialization purposes only)
      END_STRUCT;
      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;   // State in the state machine of the FB
   END_VAR

   VAR_TEMP 
      tempExecute : Bool;   // Temporary variable for input 'execute'
   END_VAR

   VAR CONSTANT 
      FB_STATE_NO_PROCESSING : DInt := 0;   // FB state: No processing
      FB_STATE_PROCESSING_1 : DInt := 1;   // FB state: Processing 1
      FB_STATE_PROCESSING_2 : DInt := 2;   // FB state: Processing 2
      STATUS_EXECUTION_FINISHED : Word := 16#0000;   // Execution finished without errors
      STATUS_NO_CALL : Word := 16#7000;   // No job being currently processed
      STATUS_FIRST_CALL : Word := 16#7001;   // First call after incoming new job (rising edge 'execute')
      STATUS_SUBSEQUENT_CALL : Word := 16#7002;   // Subsequent call during active processing without further details
      STATUS_COMMAND_ABORTED : Word := 16#7FFF;   // Commanded functionality has been aborted by another command
      SUB_STATUS_NO_ERROR : Word := 16#0000;   // NO error occurred in sub function call
      ERR_UNDEFINED_STATE : Word := 16#8600;   // Error due to an undefined state in state machine
      STATUSRANGE_DEFINITIONS_ERR_IN_BLOCK_OPERATION : Word := 16#8001;   // Status range definitions along to SIMATIC StyleGuide --> Error: Wrong operation of the function block
      STATUSRANGE_DEFINITIONS_ERR_PARAMETRIZATION : Word := 16#8200;   // Status range definitions along to SIMATIC StyleGuide --> Error: during parameterization
      STATUSRANGE_DEFINITIONS_ERR_PROCESSING_EXTERN : Word := 16#8400;   // Status range definitions along to SIMATIC StyleGuide --> Error: While processing from outside (e. g. wrong I/O signals, axis not referenced)
      STATUSRANGE_DEFINITIONS_ERR_PROCESSING_INTERN : Word := 16#8600;   // Status range definitions along to SIMATIC StyleGuide --> Error: While processing internally (e. g. when calling a system function)
      STATUSRANGE_DEFINITIONS_ERR_AREA_RESERVED : Word := 16#8800;   // Status range definitions along to SIMATIC StyleGuide --> Error: Reserved area
      STATUSRANGE_DEFINITIONS_ERR_USER_DEFINED_CLASSES : Word := 16#9000;   // Status range definitions along to SIMATIC StyleGuide --> Error: User-defined error classes
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // (c)Copyright (company) (year)
	  //-------------------------------------------------------------------------------
	  // Title:            (Title of this Block / Execute Template)
	  // Comment/Function: (that is implemented in the block)
	  //                   (Template for an FB with Execute / Busy / Done handling based on PLCopen standard "Function Blocks for Motion Control" V2.0)
	  // Library/Family:   (that the source is dedicated to)
	  // Author:           (department / person in charge / contact)
	  // Tested with:      (test system with FW version)
	  // Engineering:      TIA Portal (SW version)
	  // Restrictions:     (OB types, etc.)
	  // Requirements:     (hardware, technological package, memory needed, etc.)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | yyyy-mm-dd | (name of expert)       | First released version
	  //===============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION DESCRIPTION
	(/*
	
	*/)
	END_REGION DESCRIPTION
	
	REGION TRIGGERING
	  #tempExecute := #execute; // Work with temporary value / create process image
	  IF (#tempExecute = TRUE) AND (#statInternal.executePrevious = FALSE) // Check if FB is triggered
	    // TODO(optional): delete next line and comment line if FB shall finish current job before new job can be started with rising edge of execute
	    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)
	  THEN // First call; initialize FB
	    #statInternal.done := FALSE;
	    #statInternal.busy := TRUE;
	    #statInternal.commandAborted := FALSE;
	    #statInternal.error := FALSE;
	    #diagnostics := #statInternal.emptyDiagnostics;
	    #statInternal.diagnostics := #statInternal.emptyDiagnostics;
	    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;
	    // State machine - start processing
	    #statMainState := #FB_STATE_PROCESSING_1;
	    
	    // TODO: Initialize functionality: reset of variables, diagnostics, etc.
	    
	    // TODO: Initialize functionality: call subsidiary FBs with FALSE
	    //      #instFB(execute := FALSE);
	    
	  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN
	    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;
	  END_IF;
	  
	  // Edge detection 'execute' input
	  #statInternal.executePrevious := #tempExecute;
	END_REGION TRIGGERING
	
	IF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce "system load"
	  RETURN;
	END_IF;
	
	REGION STATE MACHINE
	  CASE #statMainState OF // State machine of FB
	    #FB_STATE_NO_PROCESSING:
	      REGION No Processing
	        ; // No processing active (Note: this state must always be present and left empty)
	      END_REGION No Processing
	      
	    #FB_STATE_PROCESSING_1: // Processing active
	      REGION Processing 1
	        // TODO: Use this state for application specific code
	        // Call subsidiary FB or functionality
	        // #instFB(execute := TRUE);
	        // IF (#instFB.done) THEN // Subsidiary FB finished successfully
	        //   #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED; // Or continue processing with next state e.g. #statFBState := FB_STATE_PROCESSING_2;
	        
	        // ELSIF (#instFB.error) THEN // Error occurred in subsidiary FB
	        //   // If the error occurred needs separate handling (e.g. close connection)
	        //   // please set the error output only when this error handling completed successfully
	        //   #statInternal.diagnostics.status := #ERR_XYZ; // Set correct status that identifies error clearly
	        //   #statInternal.diagnostics.subfunctionStatus := #instFB.status; // Status or return value of called FBs, FCs and system blocks
	        //   // TODO: Error handling
	        // ELSIF (#instFB.commandAborted) THEN // Commanded functionality has been aborted by another command
	        //   // Set
	        //   #statInternal.diagnostics.status := #STATUS_COMMAND_ABORTED;
	        //   // if that must be reported external
	        //   // #statSubfunctionStatus := #instFB.status // Status or return value of called FBs, FCs and system blocks
	        //   // #statFBErrorState := #statFBState; // Set error state number for diagnostic 
	        //   // TODO: Error handling
	        // END_IF;
	        ;
	      END_REGION Processing 1
	        
	      #FB_STATE_PROCESSING_2: // Further processing state
	        REGION Processing 2
	          // TODO: Use this state for further application specific code
	          // 
	          ;
	        END_REGION Processing 2
	        
	      ELSE // Undefined state in state machine reached
	        REGION Undefined state
	          #statInternal.diagnostics.#status := #ERR_UNDEFINED_STATE;
	        END_REGION Undefined state
	    END_CASE;
	  END_REGION STATE MACHINE
	  
	  REGION OUTPUTS
	    // Write outputs
	    IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN // Execution finished without errors
	      REGION Execution finished
	        #statInternal.done := TRUE;
	        #statInternal.busy := FALSE;
	        #statInternal.commandAborted := FALSE;
	        #statInternal.error := FALSE;
	        // execution aborted --> set state no processing
	        #statMainState := #FB_STATE_NO_PROCESSING;
	      END_REGION Execution finished    
	      
	    ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)
	      REGION Error occured
	        #statInternal.done := FALSE;
	        #statInternal.busy := FALSE;
	        #statInternal.commandAborted := FALSE;
	        #statInternal.error := TRUE;
	        // Write diagnostics
	        #statInternal.diagnostics.stateNumber := #statMainState;
	        #diagnostics := #statInternal.diagnostics;
	        // execution aborted --> set state no processing
	        #statMainState := #FB_STATE_NO_PROCESSING;
	      END_REGION Error occured
	      
	    ELSIF (#statInternal.diagnostics.status = #STATUS_COMMAND_ABORTED) AND (#statInternal.commandAborted = FALSE) THEN // Commanded functionality has been aborted by another command
	      REGION Command aborted
	        #statInternal.done := FALSE;
	        #statInternal.busy := FALSE;
	        #statInternal.commandAborted := TRUE;
	        #statInternal.error := FALSE;
	        // Write diagnostics
	        #statInternal.diagnostics.stateNumber := #statMainState;
	        #diagnostics := #statInternal.diagnostics;
	        
	        // execution aborted --> set state no processing
	        #statMainState := #FB_STATE_NO_PROCESSING;
	      END_REGION Command aborted
	      
	    ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE) OR (#statInternal.commandAborted = TRUE)) THEN // Reset outputs
	      REGION Execute reseted
	        #statInternal.done := FALSE;
	        #statInternal.busy := FALSE;
	        #statInternal.commandAborted := FALSE;
	        #statInternal.error := FALSE;
	        #statInternal.diagnostics.status := #STATUS_NO_CALL;
	        // TODO: Reset application specific outputs
	        // 
	      END_REGION Execute reseted
	    END_IF;
	    
	    REGION Write static values to outputs
	      #done := #statInternal.done;
	      #busy := #statInternal.busy;
	      #commandAborted := #statInternal.commandAborted;
	      #error := #statInternal.error;
	      #status := #statInternal.diagnostics.status;
	      // if ENO mechanism is not used / not wanted replace the following line by --> ENO := TRUE;
	      ENO := NOT #statInternal.error;
	      // TODO: Write application specific static values to outputs
	      // 
	    END_REGION Write static values to outputs
	  END_REGION OUTPUTS
	
END_FUNCTION_BLOCK

