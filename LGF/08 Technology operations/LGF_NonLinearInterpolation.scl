TYPE "LGF_typeNonLinSetpoints"
TITLE = LGF_typeNonLinSetpoints
VERSION : 0.1
//Data type to setup a setpoint table for the function `LGF_NonLinearInterpolation`
   STRUCT
      inputValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Input value to be interpolated
      outputValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Corresponding interpolated value
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "LGF_NonLinearInterpolation"
TITLE = LGF_NonLinearInterpolationCI
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industries
FAMILY : LGF
NAME : LGF_NonLinearInterpolationCI
//This function implements a characteristic curve. The characteristic curve is defined via an interpolation point table with linear interpolation between the interpolation points. A prescribed input value generates an output value in each cycle based on the characteristic curve from the interpolation point table.
   VAR_INPUT 
      value : LReal;   // Input value for calculating the output value over the defined characteristic curve.
      defaultOutValue : LReal;   // Value for pre-assignment of the output variable  (`outputValue` = `defaultOutValue`)
      enDefaultOutValue : Bool;   // Assign default output value  (`outputValue` = `defaultOutValue`)
      track : Bool;   // The value of the output `outputValue` follows the value of the input `value` without using the characteristic curve as long as this input is set. (`outputValue` = `value`)
      reset : Bool;   // If the interpolation point table is changed in running operation, the input `reset` must be activated afterwards. Otherwise, the block cannot guarantee correct execution.  (`outputValue` = 0.0)
   END_VAR

   VAR_OUTPUT 
      outputValue { ExternalWritable := 'False'} : LReal;   // The output value that has been calculated from the input value over the defined characteristic curve.
   END_VAR

   VAR_IN_OUT 
      setpoints : Array[*] of "LGF_typeNonLinSetpoints";   // Setpoint point table for defining the characteristic curve (polynomial)
   END_VAR

   VAR 
      statIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Static index of setpoint table
   END_VAR

   VAR_TEMP 
      tempValue : LReal;   // Temp representative of the input value
      tempEndOfSearch : Bool;   // Temp end of search algorithm
      tempInputValueStart : LReal;   // Temp actual setpoint - Input value - Low level
      tempInputValueEnd : LReal;   // Temp actual setpoint - Input value - High level
      tempOutputValueStart : LReal;   // Temp actual setpoint - Output value - Low level
      tempOutputValueEnd : LReal;   // Temp actual setpoint - Output value - High level
      tempFactor : LReal;   // Temp gradient of the straight line
      tempLowerBound : Int;   // Temp setpoint array lower bound
      tempUpperBound : Int;   // Temp setpoint array upper bound
   END_VAR

   VAR CONSTANT 
      ZERO : Int := 0;   // Numeric Zero constant
      SHIFT_STAT_INDEX_BY_ONE : Int := 1;   // Constant for shifting array index
      DIMENSION_ONE : UDInt := 1;   // First dimension of an array
   END_VAR


BEGIN
	REGION Block info header
	  //=============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-----------------------------------------------------------------------------
	  // Title:            LGF_NonLinearInterpolation
	  // Comment/Function: Interpolates a charachteristic curve via pre-defined array of setpoints.
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15 Update 2
	  // Restrictions:     ENO disabled - error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 04.01.2017  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.00.02 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.00.06 15.11.2019  Simatic Systems Support
	  //                      Regions, comments and constants are added
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 22.03.2021  Simatic Systems Support
	  //                      Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	The value of the output `outputValue` based on the following priority:
	
	1. As long as the input `enDefaultOutValue` is set, the value defined via the parameter `defaultOutValue` will be output as output value.
	2. As long as the input `reset` is set, the block is reset and the output value is `0.0`.
	3. If the input `track` is set, the output value will be output directly as input value, without consideration of the characteristic curve.
	4. Based on the input value, a characteristic curve value is calculated via the linearly interpolated, interpolation point table and output as an output value.
	  * If the input value is between two interpolation points within the interpolation point table, the output value is calculated as the intersection with the connecting line between the preceding and following interpolation points (see Figure below).
	  * If the input value is before the first interpolation point (lowest value defined in the interpolation point table), the output value will be calculated as the intersection of the line formed by the first two interpolation points of the interpolation point table.
	  * If the input value is after the last interpolation point (highest value defined in the interpolation point table), the output value will be calculated as the intersection of the line formed by the last two interpolation points of the interpolation point table.
	
	#### Interpolation point table
	The interpolation point table is implemented through a variable of the data type Array. The type of the array corresponds to the PLC data type `LGF_typeNonLinSetpoints`.
	
	You can create the interpolation point table in any global data block. The size of the array depends on the number of interpolation points.
	
	------
	
	Figure: Sample path of the output signal
	
	![LGF_NonLinearInterpolation Setpoint table](LGF_NonLinearInterpolation.png "LGF_NonLinearInterpolation Setpoint table")
	
	---
	
	NOTICE
	:    To keep the computing time of the block as short as possible, there is no check of the parameterization or the data of the interpolation point table.
	:    When entering the interpolation points in the interpolation point table, the following particularities must be considered. If these particularities are not taken into account, it can lead to a malfunction of the block.
	* At least two interpolation points must be entered in the interpolation point table.
	* The interpolation points in the interpolation point table must be entered in the Table in ascending order of the input values.
	
	#### Example
	
	Figure: Sample data block
	
	![LGF_NonLinearInterpolation_Table Setpoint table](LGF_NonLinearInterpolation_Table.png "LGF_NonLinearInterpolation_Table Setpoint table")
	*/)
	END_REGION DESCRIPTION
	
	REGION Initialization
	  #tempValue := #value;
	  //Call "LOWER_BOUND" and "UPPER_BOUND" for the setpoints
	  #tempLowerBound := DINT_TO_INT(LOWER_BOUND(ARR := #setpoints, DIM := #DIMENSION_ONE));
	  #tempUpperBound := DINT_TO_INT(UPPER_BOUND(ARR := #setpoints, DIM := #DIMENSION_ONE));
	  
	  //Check index value
	  IF (#statIndex < #tempLowerBound) OR (#statIndex > #tempUpperBound) OR (#statIndex = #ZERO) THEN
	    #statIndex := #tempLowerBound + #SHIFT_STAT_INDEX_BY_ONE;
	  END_IF;
	END_REGION
	
	REGION Different modes
	  IF #enDefaultOutValue THEN
	    //Set output value
	    #outputValue := #defaultOutValue;
	    RETURN;
	  ELSIF #track THEN
	    //Set output value
	    #outputValue := #tempValue;
	    RETURN;
	  ELSIF #reset THEN
	    //Preset search index of array
	    #statIndex := #tempLowerBound + #SHIFT_STAT_INDEX_BY_ONE;
	    #outputValue := #ZERO;
	    RETURN;
	  END_IF;
	END_REGION
	
	REGION Calculated polynom output
	  //Initialize search procedure
	  #tempEndOfSearch := False;
	  
	  //Search procedure
	  REPEAT
	    //Preset input values of polygon
	    #tempInputValueStart := #setpoints[#statIndex - #SHIFT_STAT_INDEX_BY_ONE].inputValue;
	    #tempInputValueEnd := #setpoints[#statIndex].inputValue;
	    
	    //Check actual polynom
	    IF (#tempValue > #tempInputValueStart) THEN
	      IF (#tempValue > #tempInputValueEnd) THEN
	        IF (#statIndex < #tempUpperBound) THEN
	          #tempInputValueStart := #tempInputValueEnd;
	          #statIndex := #statIndex + #SHIFT_STAT_INDEX_BY_ONE;
	          #tempInputValueEnd := #setpoints[#statIndex].inputValue;
	        ELSE
	          #tempEndOfSearch := True;
	        END_IF;
	      ELSE
	        #tempEndOfSearch := True;
	      END_IF;
	    ELSE
	      IF (#statIndex > (#tempLowerBound + #SHIFT_STAT_INDEX_BY_ONE)) THEN
	        #statIndex := #statIndex - #SHIFT_STAT_INDEX_BY_ONE;
	        #tempInputValueEnd := #tempInputValueStart;
	        // #tempInputValueStart := #setpoints.Point[#statIndex - 1].InputValue;
	        #tempInputValueStart := #setpoints[#statIndex].inputValue;
	      ELSE
	        #tempEndOfSearch := True;
	      END_IF;
	    END_IF;
	  UNTIL (#tempEndOfSearch = True) END_REPEAT;
	  
	  // Set output values of polygon
	  #tempOutputValueStart := #setpoints[#statIndex - #SHIFT_STAT_INDEX_BY_ONE].outputValue;
	  #tempOutputValueEnd := #setpoints[#statIndex].outputValue;
	  // Calculate gradient of straight line
	  #tempFactor := (#tempOutputValueEnd - #tempOutputValueStart) / (#tempInputValueEnd - #tempInputValueStart);
	END_REGION
	
	REGION Writting to outputs
	  // Calculate output value
	  #outputValue := (#tempFactor * #tempValue) + (#tempOutputValueStart - (#tempFactor * #tempInputValueStart));
	  
	  // ENO mechanism is not used
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION_BLOCK

