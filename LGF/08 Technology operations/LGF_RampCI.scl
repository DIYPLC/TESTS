TYPE "LGF_typeRampTimeTable"
TITLE = LGF_typeRampTimeTable
VERSION : 0.1
//Data type to setup a speed curve based on a setpoint table for the function `LGF_RampCI`
   STRUCT
      outputValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Setpoint Value to reach by the interpolation curve
      "time" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Time until the interpolation point is reached
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "LGF_RampCI"
TITLE = LGF_RampCI
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industries
FAMILY : LGF
NAME : LGF_RampCI
//The function generates a speed curve based on an interpolation point table. Linear interpolation occurs between the points within the prescribed time.
   VAR_INPUT 
      defaultOutValue : LReal := 0.0;   // Value for pre-assignment of the output variable  (`outputValue` = `defaultOutValue`)
      contStepNbr : Int := 0;   // Number of the next interpolation point for continuing
      contStepTime : Time := T#0MS;   // Remaining time to continue to the interpolation point `contStepNbr`
      enDefaulftOutValue : Bool := FALSE;   // Assign default output value  (`outputValue` = `defaultOutValue`)
      start : Bool := FALSE;   // Run down the interpolation point table
      hold : Bool := FALSE;   // Freeze/ hold output at actual value
      continue : Bool := FALSE;   // Continuing
      cyclicOP : Bool := FALSE;   // Repeat interpolation point table cyclically
      updateTime : Bool := FALSE;   // Update time values
      reset : Bool := FALSE;   // Complete reset of function
      callOB : OB_CYCLIC;   // Calling wake-alarm interrupt OB (cyclic interrupt OB)
   END_VAR

   VAR_OUTPUT 
      outputValue { ExternalWritable := 'False'} : LReal;   // Output value
      actTimeTable { ExternalWritable := 'False'} : Bool;   // The interpolation point table will be edited.
      stepNumber { ExternalWritable := 'False'} : Int;   // current interpolation point number  (interpolation point that is approached)
      remainTime { ExternalWritable := 'False'} : Time;   // Remaining time until reaching the next interpolation point
      totalTime { ExternalWritable := 'False'} : Time;   // Total time for setpoint table
      remainTotalTime { ExternalWritable := 'False'} : Time;   // Total remaining time
      error { ExternalWritable := 'False'} : Bool;   // FALSE: No error  TRUE: An error occurred during the execution of the FB
      status { ExternalWritable := 'False'} : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
      subfunctionStatus { ExternalWritable := 'False'} : Word;   // Status or return value of called FB's, FC's and system blocks
   END_VAR

   VAR_IN_OUT 
      setpoints : Array[*] of "LGF_typeRampTimeTable";   // Interpolation point table.  You can find information on the data type `LGF_typeRampTimeTable` under the item “Global data” .
   END_VAR

   VAR 
      statEndValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Static end value of interpolated interval
      statOldValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;   // Static previous interpolated value
      statActualStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Static current step from setpoint array
      statActualRestTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Static actual remaining time of current step execution
      statTotalTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Static total time of the ramp cycle
      statRestTotalTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Static remaining total time
      statStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static flag for starting the function
      statTimeTableActiv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static interpolation point table will be edited
      statStartMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static memory of `Start` bit from previous scan
      statUpdateTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static memory of `UpdateTime` bit from previous scan
      statReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static flag that the function is resetting
      statResetMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static memory of `Reset` bit from previous scan
   END_VAR

   VAR_TEMP 
      tempNewValue : LReal;   // Temp calculated current function value
      tempIndex : Int;   // Temp "FOR" instruction index counter
      tempArrayLowLim : Int;   // Temp lower bound of setpoint array
      tempArrayUpLim : Int;   // Temp upper bound of setpoint array
      tempSampleTime : Time;   // Temp sample time in miliseconds converted from QRY_CINT function
      tempCycleTime : UDInt;   // Temp cycle time from CallOB
      tempCyclePhase : UDInt;   // Temp cycle phase from CallOB
      tempCycleStatus : Word;   // Temp cycle status from CallOB
      tempReadTimeStatus : Int;   // Temp return value of QRY_CINT
      tempStatus : Word;   // Temp status of the function
   END_VAR

   VAR CONSTANT 
      ZERO : Int := 0;   // Numeric Zero constant
      NO_ERROR : Int := 0;   // No error
      RESET_TIME : Time := T#0MS;   // Reset time value
      CYCLIC_OB_NOT_AVAILABLE : Word := 16#0000;   // Cyclic interrupt OB is not available
      DIMENSION_ONE : UDInt := 1;   // First dimension of an array
      SECOND_IN_MS : UDInt := 1000;   // One second written in miliseconds. Needed in calculation in formulas
      SUB_STATUS_NO_ERROR : Word := 16#0000;   // Subfunction status: No error
      STATUS_FINISHED_NO_ERROR : Word := 16#0000;   // Status: Execution finished without errors
      STATUS_NO_CALL : Word := 16#7000;   // Status: Block is not being processed
      STATUS_FIRST_CALL : Word := 16#7001;   // Status: First call,  Rising edge `start`.
      STATUS_FURTHER_CALLS : Word := 16#7002;   // Status: Further calls, cyclic operation,  Input `cyclicOP` set.
      ERR_OB_UNAVAILABLE : Word := 16#8200;   // Error: OB on input `callOB` is not configured / present.  Interconnect the constant name of a configured cyclic interrupt OB at the input `callOB`.
      ERR_ARRAY_LOWER_BOUND : Word := 16#8201;   // Error: Array does not start with 0 / Low array limit <> 0.  The array with the interpolation points must start with the index 0.
      ERR_QRY_CINT : Word := 16#8400;   // Error in `QRY_CINT` command - check `subFunctionStatus` code
   END_VAR


BEGIN
	REGION Block info header
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_RampCI
	  // Comment/Function: Generates a speed curve based on an interpolation point table.
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15 Update 2
	  // Restrictions:     ENO disabled - error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 03.02.2017  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 16.05.2017  Siemens Industry Online Support
	  //                      Comment correction (REGION)
	  // 01.00.02 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.00.03 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.00.06 15.11.2019  Siemens Industry Presales Support
	  //                      Code optimization, Regions, comments and constants are added
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 22.03.2021  Simatic Systems Support
	  //                      Insert documentation
	  //                      Change UDT member name from `outValue` to `outputValue`
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	NOTE
	:    The status of called commands is output in `subFunctionStatus`. In this case, the output value in `status` indicates which command caused the error. In this case, refer to the TIA Portal Online Help section for information on the respective commands.
	
	---
	
	#### Global data
	Together with the block, you automatically receive the PLC data type `LGF_typeRampTimeTable`, which is composed of the parameters `outVal` for the value of a base point and `time` for the time, until the next base point is reached. The declaration takes place in a one-dimensional array of the data type `LGF_typeRampTimeTable` beginning with the index `0`. The array is created in a global data block and then passed to the module `LGF_RampCI`.
	
	Figure: Example of the declaration of the interpolation points
	
	![LGF_RampCI Setpoint table](LGF_RampCI_table.png "LGF_RampCI Setpoint table")
	
	The parameter `time` of the last interpolation point must be parameterized with `0s`, since there is no longer any successor interpolation point.
	
	#### Principle of operation
	With this block, speed curves can be executed based on parameterized interpolation points; in each call cycle values are output according to a schedule, and interpolation takes place between the interpolation points.
	
	In each cycle the currently approached interpolation point number `stepNumber`, the actual remaining time `remainTime` until reaching the interpolation point, the total time `totalTime,` and the total remaining time until reaching the end of the speed curve `remainTotalTime`, are output. In addition, the output `actTimeTable` is set if the projected speed curve is currently being output.
	
	The time interval of the calling cyclic interrupt OB is determined by interconnecting the calling cyclic interrupt OB at the input parameter `callOB`.
	
	Figure: Interconnecting the cyclic interrupt OB
	
	![Interconnecting the cyclic interrupt OB](LGF_InterruptObAsParameter.png "Interconnecting the cyclic interrupt OB")
	
	The following operating modes can be selected via control inputs:
	
	* Restart
	* Pre-assigning an output
	* Output a speed curve
	* Stop processing
	* Specify processing step and processing time
	* Switch-on cyclic operation+F1
	* Update total time and remaining time
	
	#### Overview of the operating modes
	Table: Overview of the operating modes
	
	![LGF_RampCI Table: Overview of the operating modes](LGF_RampCI_OperationTable_EN.png "LGF_RampCI Table: Overview of the operating modes")
	
	------
	
	#### Restart
	The output `outValue` is reset to `0.0` with a rising edge at the input `reset`. With `enDefaultOutValue = TRUE`, `defaultOutValue` is output at `outputValue`. The total time and total remaining time are updated and output.
	
	#### Pre-assigning an output
	If the speed curve should begin with a certain output value, then `enDefaultOutValue` must be `TRUE`. In this case the value `defaultOutValue` is present on the output of the timer. The internal processing of the speed curve continues during this time. If `enDefaultOutValue` changes to `FALSE` again, interpolation is performed to the currently active calibration point.
	
	#### Output a speed curve
	With a rising edge at the input `start`, the speed curve is output - as long as `start` is `TRUE` or until the speed curve is terminated by reaching the last interpolation point. Through a subsequent rising edge, the speed curve is output again. In addition, the total time is updated at each switch-on.
	
	#### Switch-on cyclic operation
	If, in addition to the input `start`, the input `cyclicOP` is also set to `TRUE`, the speed curve automatically returns to the start point after outputting the last interpolation point value and starts a new cycle.
	
	There is no interpolation between the last interpolation point value and the starting point. The following must apply for a smooth transition: last interpolation point value = start point.
	
	#### Stop speed curve
	With `hold = TRUE` the value of the output variable (including time processing) is frozen. When resetting `hold = FALSE`, the program continues at the point of interruption or at a parameterized point (see "Defining the processing step and processing time"). The processing time of the speed curve is extended by the holding time `T1*`. (see Figure below).
	
	#### Specify processing step and processing time
	If the input parameter `continue` is set to `TRUE` for continuation while the speed curve is stopped (`hold = TRUE`), then after the input `hold` has been reset the interpolation point number `contStepNbr` (target interpolation point) will be approached within the time `contStepTime` (interpolation). The total remaining time will be recalculated.
	
	#### Updating total time and total remaining time
	If values of the interpolation points are changed, the total time and the total remaining time of the speed curve can change. Since calculation of `totalTime` and `remainTotalTime` can significantly increase the processing time of the function block at many interpolation points, the calculation is only executed once with a rising edge on the `updateTime` input.
	
	-------
	
	#### Functional processes
	Figure: Functional processes
	
	![LGF_RampCI Functional processes](LGF_RampCI.png "LGF_RampCI Functional processes")
	*/)
	END_REGION DESCRIPTION
	
	REGION Cycle time
	  // get sample time, according to the cyclic interrupt OB number
	  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime, PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);
	  #tempCycleTime := #tempCycleTime / #SECOND_IN_MS; // microsecond --> milisecond 
	  #tempSampleTime := UDINT_TO_TIME(#tempCycleTime); // Format: TIME
	  
	  #tempStatus := #STATUS_NO_CALL;
	  
	  // Generate error message of the QRY_CINT function
	  IF (#tempReadTimeStatus <> #NO_ERROR) THEN
	    #error := TRUE;
	    #subfunctionStatus := INT_TO_WORD(#tempReadTimeStatus);
	    #status := #ERR_QRY_CINT;
	    RETURN;
	  END_IF;
	  
	  // Generate error message when OB unavailable
	  IF #tempCycleStatus = #CYCLIC_OB_NOT_AVAILABLE THEN
	    #error := TRUE;
	    #status := #ERR_OB_UNAVAILABLE;
	    #subfunctionStatus := #SUB_STATUS_NO_ERROR;
	    RETURN;
	  END_IF;
	END_REGION Cycle time
	
	REGION Array lower/upper bound
	  #tempArrayLowLim := DINT_TO_INT(LOWER_BOUND(ARR := #setpoints, DIM := #DIMENSION_ONE));
	  #tempArrayUpLim := DINT_TO_INT(UPPER_BOUND(ARR := #setpoints, DIM := #DIMENSION_ONE));
	  
	  IF #tempArrayLowLim <> #ZERO THEN
	    #error := TRUE;
	    #status := #ERR_ARRAY_LOWER_BOUND;
	    #subfunctionStatus := #SUB_STATUS_NO_ERROR;
	    RETURN;
	  END_IF;
	END_REGION Array lower/upper bound
	
	REGION Function  
	  REGION First Call
	    // START by positive edge
	    IF #start AND NOT #statStartMem THEN
	      #tempStatus := #STATUS_FIRST_CALL;
	      #statStart := TRUE;
	      #statTotalTime := #RESET_TIME; // reset total time 
	      
	      FOR #tempIndex := #tempArrayLowLim TO #tempArrayUpLim DO // calculate total time 
	        #statTotalTime := #statTotalTime + #setpoints[#tempIndex]."time"; // total time 
	      END_FOR;
	      #statRestTotalTime := #statTotalTime;
	      #statReset := FALSE;
	    ELSIF NOT #start THEN
	      #error := false;
	      #subfunctionStatus := #SUB_STATUS_NO_ERROR;
	      #status := #STATUS_FINISHED_NO_ERROR;
	    END_IF;
	    // store old value for edge detection
	    #statStartMem := #start;
	  END_REGION First Call
	  
	  REGION Reset    
	    // RESET by positiv edge on reset
	    IF #reset AND NOT #statResetMem THEN
	      #tempStatus := #STATUS_FINISHED_NO_ERROR;
	      #statTotalTime := #RESET_TIME; // reset total time 
	      
	      FOR #tempIndex := #tempArrayLowLim TO #tempArrayUpLim DO // calculate total time 
	        #statTotalTime := #statTotalTime + #setpoints[#tempIndex]."time"; // total time 
	      END_FOR;
	      
	      #tempNewValue := #ZERO;                   // output outValue = 0 
	      #statRestTotalTime := #statTotalTime;     // update remaining total time 
	      #statEndValue := #ZERO;                   // reset statEndValue    
	      #statActualStep := #ZERO;                 // reset statActualStep  
	      #statActualRestTime := #RESET_TIME;       // reset statActualTime 
	      #statStart := TRUE;                       // set start condition 
	      #statTimeTableActiv := FALSE;             // reset statTimeTableActive 
	      #statReset := TRUE;
	    END_IF;
	    // store old value for edge detection
	    #statResetMem := #reset;
	  END_REGION Reset
	  
	  REGION Operation 
	    IF #start AND NOT #statReset THEN
	      // start function ramp soak 
	      IF #statStart THEN
	        // Set up start conditions 
	        #tempNewValue := #setpoints[#tempArrayLowLim].outputValue;
	        #statEndValue := #setpoints[#tempArrayLowLim + 1].outputValue;
	        #statActualRestTime := #setpoints[#tempArrayLowLim]."time";
	        #statRestTotalTime := #statTotalTime;
	        #statActualStep := 1;
	        #statStart := FALSE;
	        #statTimeTableActiv := TRUE;
	      ELSE
	        IF #hold THEN
	          // Freeze operation 
	          #statTimeTableActiv := FALSE;
	          #tempNewValue := #statOldValue;
	          
	          IF #continue THEN
	            // Set up continue conditions 
	            // Continue step and remaining time untill continue step
	            #statEndValue := #setpoints[#contStepNbr].outputValue;
	            #statRestTotalTime := #contStepTime;
	            #statActualRestTime := #contStepTime;
	            #statActualStep := #contStepNbr;
	            
	            FOR #tempIndex := #statActualStep TO #tempArrayUpLim DO // calculating remaining total time  
	              #statRestTotalTime := #statRestTotalTime + #setpoints[#tempIndex]."time"; // Remaining total time
	            END_FOR;
	          END_IF;
	        ELSE
	          // normal operation 
	          // remaining time until actual step 
	          IF #statActualRestTime > #tempSampleTime THEN
	            // calculate new output value, if remaining time has not yet expired
	            #tempNewValue := #statOldValue + (#statEndValue - #statOldValue) / DINT_TO_REAL(TIME_TO_DINT(#statActualRestTime)) * UDINT_TO_REAL(#tempCycleTime);
	            // update remaining time till actual step 
	            #statActualRestTime := #statActualRestTime - #tempSampleTime;
	            // update remaining total time 
	            #statRestTotalTime := #statRestTotalTime - #tempSampleTime;
	          ELSE
	            // remaining actual rest time expired 
	            #statActualRestTime := #RESET_TIME;
	            // End of step numbers not reached yet    
	            IF #statActualStep < #tempArrayUpLim THEN
	              // set new end value 
	              #statEndValue := #setpoints[#statActualStep + 1].outputValue;
	              // set new output value 
	              #tempNewValue := #setpoints[#statActualStep].outputValue;
	              // new remaining actual time 
	              #statActualRestTime := #setpoints[#statActualStep]."time";
	              #statActualStep := #statActualStep + 1;
	              #statTimeTableActiv := TRUE;
	              #statRestTotalTime := #statRestTotalTime - #tempSampleTime;
	            ELSE
	              // end of step numbers reached 
	              #tempStatus := #SUB_STATUS_NO_ERROR;
	              #statRestTotalTime := #RESET_TIME;
	              // cyclic operation
	              IF #cyclicOP THEN
	                #statStart := TRUE;
	                #tempStatus := #STATUS_FURTHER_CALLS;
	              ELSE
	                #statTimeTableActiv := FALSE;
	              END_IF;
	              // set new output value 
	              #tempNewValue := #setpoints[#statActualStep].outputValue;
	            END_IF;
	          END_IF;
	        END_IF;
	      END_IF;
	    ELSE
	      #tempNewValue := #ZERO;
	      // time table not active 
	      #statTimeTableActiv := FALSE;
	    END_IF;
	  END_REGION Operation 
	  
	  REGION Update time
	    // Update total time and remaining total time
	    // Positive edge detection of update time input
	    IF #updateTime AND NOT #statUpdateTime THEN
	      #statTotalTime := #RESET_TIME; // reset total time 
	      #statRestTotalTime := #statActualRestTime; // copy remaining actual time to remaining total time
	      
	      FOR #tempIndex := #tempArrayLowLim TO #tempArrayUpLim DO // calculate totel time 
	        #statTotalTime := #statTotalTime + #setpoints[#tempIndex]."time"; // total time 
	      END_FOR;
	      
	      FOR #tempIndex := #statActualStep TO #tempArrayUpLim DO // calculate remaining total time 
	        #statRestTotalTime := #statRestTotalTime + #setpoints[#tempIndex]."time"; // remaining total time 
	      END_FOR;
	    END_IF;
	    // store old value for edge detection
	    #statUpdateTime := #updateTime;
	  END_REGION Update time
	  
	  REGION Default output
	    // default value activated: overwrite output by default value
	    IF #enDefaulftOutValue THEN
	      #tempNewValue := #defaultOutValue; // preset output 
	      #statTimeTableActiv := FALSE; // timetable not active 
	    END_IF;
	  END_REGION Default output
	END_REGION Function 
	
	REGION Write outputs
	  #outputValue := #tempNewValue; // output
	  #statOldValue := #tempNewValue; // store prvious value
	  #actTimeTable := #statTimeTableActiv; //time table active
	  #stepNumber := #statActualStep; // number of acting step
	  #remainTime := #statActualRestTime; // remaining time till actual step
	  #totalTime := #statTotalTime; // total time
	  #remainTotalTime := #statRestTotalTime; //remaining total time
	  
	  #error := #tempStatus.%X15;
	  #status := #tempStatus;
	  #subfunctionStatus := #SUB_STATUS_NO_ERROR;
	  
	  // ENO mechanism is not used
	  ENO := TRUE;
	END_REGION Write outputs
	
END_FUNCTION_BLOCK

