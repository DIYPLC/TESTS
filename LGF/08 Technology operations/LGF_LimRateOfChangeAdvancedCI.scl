FUNCTION_BLOCK "LGF_LimRateOfChangeAdvancedCI"
TITLE = LGF_LimRateOfChangeAdvancedCI
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industries
FAMILY : LGF
NAME : LGF_LimRateOfChangeAdvancedCI
//The function `LGF_LimRateOfChangeAdvanced` limits the rate of change of an input variable. Jump functions become ramp functions. In addition, the block has various operating modes.
   VAR_INPUT 
      autoValue : LReal;   // Signal to be processed and limited in its rate of change
      manualValue : LReal;   // Manually controlled output value  (`outputValue` = `manualValue`)
      setPosUpRateLim : LReal;   // Rate of change per second for the rising ramp in the positive value range (1/second)
      setPosDownRateLim : LReal;   // Rate of change per second for the falling ramp in the positive value range (1/second)
      setNegUpRateLim : LReal;   // Rate of change per second for the rising ramp in the negative value range (1/second)
      setNegDownRateLim : LReal;   // Rate of change per second for the falling ramp in the negative value range (1/second)
      setHighLim : LReal;   // High limit value
      setLowLim : LReal;   // Low limit value
      defaultOutValue : LReal;   // Value for pre-assignment of the output variable  (`outputValue` = `defaultOutValue`)
      enDefaultOutValue : Bool;   // Assign default output value  (`outputValue` = `defaultOutValue`)
      track : Bool;   // Follow / tracking of Input variable  (`outputValue` = `autoValue`)
      manOp : Bool;   // Manual mode on  (`outputValue` = `manualValue`)
      reset : Bool;   // Complete restart of function
      callOB : OB_CYCLIC;   // Calling wake-alarm interrupt OB (cyclic interrupt OB)
   END_VAR

   VAR_OUTPUT 
      outputValue { ExternalWritable := 'False'} : LReal;   // Output variable
      posUpRateLim { ExternalWritable := 'False'} : Bool;   // Rise limitation in positive range tripped
      posDownRateLim { ExternalWritable := 'False'} : Bool;   // Down rate limit in positive range reached
      negUpRateLim { ExternalWritable := 'False'} : Bool;   // Up rate limit in negative range reached
      negDownRateLim { ExternalWritable := 'False'} : Bool;   // Down rate limit in negative range reached
      highLim { ExternalWritable := 'False'} : Bool;   // High limit reached
      lowLim { ExternalWritable := 'False'} : Bool;   // Low limit reached
      error { ExternalWritable := 'False'} : Bool;   // FALSE: No error  TRUE: An error occurred during the execution of the FB
      status { ExternalWritable := 'False'} : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
      subfunctionStatus { ExternalWritable := 'False'} : Word;   // Status or return value of called FB's, FC's and system blocks
   END_VAR

   VAR 
      statPrevOutputValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;   // Static previous cycle output value
      statManOp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static manual mode flag
   END_VAR

   VAR_TEMP 
      tempPosUp : Bool;   // Temp up rate limit in positive range reached
      tempPosDown : Bool;   // Temp down rate limit in positive range reached
      tempNegUp : Bool;   // Temp up rate limit in negative range reached
      tempNegDown : Bool;   // Temp down rate limit in negative range reached
      tempHighLim : Bool;   // Temp high limit reached
      tempLowLim : Bool;   // Temp low limit reached
      tempCycleReal : LReal;   // Temp cycle time converted from miliseconds to seconds
      tempOutv : LReal;   // Temp used for swaping data between variables
      tempVar : LReal;   // Temp rate of change
      tempCycleTime : UDInt;   // Temp cycle time from CallOB
      tempCyclePhase : UDInt;   // Temp cycle phase from CallOB
      tempCycleStatus : Word;   // Temp cycle status from CallOB
      tempReadTimeStatus : Int;   // Temp return value of QRY_CINT
   END_VAR

   VAR CONSTANT 
      ZERO_INT : Int := 0;   // Numeric zero value - integer format
      ZERO_REAL : LReal := 0.0;   // Numeric zero value - real format
      SECOND_IN_MICROSECONDS : LReal := 1000000.0;   // One second written in miliseconds. Needed in calculation in formulas
      SUB_STATUS_NO_ERROR : Word := 16#0000;   // Subfunction status: No error
      STATUS_FINISHED_NO_ERROR : Word := 16#0000;   // Status: Execution finished without errors
      ERR_NEG_RATE_LIM : Word := 16#8200;   // Error: High limit lower than low limit.  The high limit `setHighLim` must be greater than the low limit `setLowLim`.
      ERR_NEG_RATE_OF_CHANGE : Word := 16#8202;   // Error: Negative rate of change.  The parameter for the change rate must not be negative.
      ERR_QRY_CINT : Word := 16#8600;   // Error in `QRY_CINT` command - check `subFunctionStatus` code
      ERR_OB_UNAVAILABLE : Word := 16#8601;   // Error: OB on input `callOB` is not configured / present.  Interconnect the constant name of a configured cyclic interrupt OB at the input `callOB`.
   END_VAR


BEGIN
	REGION Block info header
	  //=============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_LimRateOfChangeAdvancedCI
	  // Comment/Function: Generates a ramp function from a step function.
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15 Update 2
	  // Restrictions:     ENO disabled - error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 21.06.2016  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 02.01.2017  Siemens Industry Online Support
	  //                      Upgrade: TIA Portal V14 Update 1
	  // 01.00.02 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.00.03 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.00.07 15.11.2019  Simatic Systems Support
	  //                      Regions, comments and constants are added
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 22.03.2021  Simatic Systems Support
	  //                      Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	NOTE
	:    The status of called commands is output in `subFunctionStatus`. In this case, the output value in `status` indicates which command caused the error. In this case, refer to the TIA Portal Online Help section for information on the respective commands.
	
	---
	
	For the positive/negative value range, two rates of change in each case for the ramp (rising and falling values) can be parameterized. The following operating modes can be selected via control inputs:
	
	* Restart
	* Pre-assigning an output
	* Normal operation (automatic)
	* Switch through controlled variable (manual)
	* Tracking
	
	The output variable can be limited through two parametrize able limits. An active limitation of the rate of change of a ramp, as well as an active limitation of the output variable are reported via outputs.
	
	The time interval of the calling cyclic interrupt OB is determined by interconnecting the calling cyclic interrupt OB at the input parameter `callOB`.
	
	![Interconnecting the cyclic interrupt OB](LGF_InterruptObAsParameter.png "Interconnecting the cyclic interrupt OB")
	
	#### Restart
	
	At restart `reset = TRUE`, the output `outputValue` is reset to `0.0`.  
	If `enDefaultOutValue = TRUE` is set, `defaultOutValue` is output. All signal outputs are set to `FALSE`.
	
	#### Pre-assigning an output
	
	If `enDefaultOutValue = TRUE` is set, the value at `defaultOutValue` is output. When changing from `TRUE` to `FALSE`, `outputValue` is ramped from `defaultOutValue` to `autoValue`. When changing from `FALSE` to `TRUE`, the output `outputValue` immediately jumps to `defaultOutValue`.
	
	#### Normal operation
	
	The ramps are straight lines of limitation and are based on a rate of change per second; if, for example, the parameter `setPosUpRateLim = 10.0` is assigned, then at a sampling time of 1s/100ms/10ms, 10.0/1.0/0.1 will be added to `outputValue` at each block call, if `autoValue > outputValue`, until `autoValue` is reached.
	
	The limitation of the rate of change can be parameterized in both positive and negative ranges for the increase and decrease.
	
	------
	
	Table: Marking of the ramps
	
	+-------------------+-----------------------------------------------------------------------+
	| Parameters        | Ramp                                                                  |
	+-------------------+-----------------------------------------------------------------------+
	| setPosUpRateLim   | `outputValue > 0.0` and `|outputValue|` rising
	+-------------------+-----------------------------------------------------------------------+
	| setPosDownRateLim | `outputValue > 0.0` and `|outputValue|` falling
	+-------------------+-----------------------------------------------------------------------+
	| setNegUpRateLim   | `outputValue < 0.0` and `|outputValue|` rising
	+-------------------+-----------------------------------------------------------------------+
	| setNegDownRateLim | `outputValue < 0.0` and `|outputValue|` falling
	+-------------------+-----------------------------------------------------------------------+
	 
	
	If the ramps are not parameterized (`setPosUpRateLim`, `setPosDownRateLim`, `setNegUpRateLim`, and `setNegDownRateLim` equal `0.0`), the output remains at `0.0` and normal operation is disabled.
	
	#### Tracking
	
	If the input `track = TRUE` is set, the input variable `autoValue` is interconnected directly to the output variable `outputValue`. Thus, jumps of the input variable will also be output.
	
	#### Switch through controlled variable
	
	If `manOp = TRUE` is set, the controlled variable `manualValue` is interconnected directly to the output variable `outputValue`.
	
	In this operating mode, the parameterization of the ramps or the high/low limitation of the output variable, and the pre-assignment of the output, are ineffective.
	
	When changing from `TRUE` to `FALSE`, the output `outputValue` is ramped again after `autoValue`.
	
	As soon as the value range between the low and high limits is reached, the high and low limits are reactivated.
	
	Figure: Ramp function sequence, operating modes
	
	![LGF_LimRateOfChangeAdvancedCI](LGF_LimRateOfChangeAdvancedCI.png "LGF_LimRateOfChangeAdvancedCI")
	*/)
	END_REGION DESCRIPTION
	
	REGION Initialization
	  #tempPosUp := FALSE;
	  #tempPosDown := FALSE;
	  #tempNegUp := FALSE;
	  #tempNegDown := FALSE;
	  #tempHighLim := FALSE;
	  #tempLowLim := FALSE;
	  #tempOutv := #autoValue;
	  
	  // get sample time, according to the cyclic interrupt OB number
	  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime, PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);
	  #tempCycleReal := UDINT_TO_REAL(#tempCycleTime) / #SECOND_IN_MICROSECONDS; // Time in seconds
	END_REGION
	
	REGION Validation
	  // Generate error message of the QRY_CINT function
	  IF (#tempReadTimeStatus <> #ZERO_INT) THEN
	    #error := TRUE;
	    #subfunctionStatus := INT_TO_WORD(#tempReadTimeStatus);
	    #status := #ERR_QRY_CINT;
	    RETURN;
	  END_IF;
	  
	  // Generate error message when OB unavailable
	  IF #tempCycleStatus = #SUB_STATUS_NO_ERROR THEN
	    #error := TRUE;
	    #status := #ERR_OB_UNAVAILABLE;
	    #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;
	    RETURN;
	  END_IF;
	  
	  //Check high with low limit
	  IF #setHighLim < #setLowLim THEN
	    #error := TRUE;
	    #status := #ERR_NEG_RATE_LIM;
	    #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;
	    RETURN;
	  END_IF;
	  
	  //Check rate limits for negative values
	  IF (#setNegDownRateLim < #ZERO_REAL) OR (#setNegUpRateLim < #ZERO_REAL)
	    OR (#setPosDownRateLim < #ZERO_REAL) OR (#setPosUpRateLim < #ZERO_REAL) THEN
	    #error := TRUE;
	    #status := #ERR_NEG_RATE_OF_CHANGE;
	    #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;
	    RETURN;
	  END_IF;
	END_REGION
	
	REGION Function processing
	  // RESTART
	  // reset manual mode flag 
	  IF #reset THEN
	    #statManOp := FALSE;
	    IF #enDefaultOutValue THEN
	      // preset output
	      #tempOutv := #defaultOutValue;
	      // limitation of output
	      // High limitation
	      IF #tempOutv >= #setHighLim THEN
	        #tempOutv := #setHighLim;
	        #tempHighLim := TRUE;
	      END_IF;
	      
	      // Low limitation
	      IF #tempOutv <= #setLowLim THEN
	        #tempOutv := #setLowLim;
	        #tempLowLim := TRUE;
	      END_IF;
	    ELSE
	      // reset output
	      #tempOutv := #ZERO_REAL;
	    END_IF;
	  ELSE
	    // OPERATING MODES
	    // -------------------------------------------------------
	    IF #manOp THEN
	      //---// MANUAL MODE
	      // bumples switch between manual mode and auto mode
	      #tempOutv := #manualValue;
	      // Keep manual mode until setpoint in the space of low and high limit
	      #statManOp := TRUE;
	    ELSE
	      //---// AUTOMATIC MODE
	      IF #enDefaultOutValue THEN
	        // preset output by default value
	        #tempOutv := #defaultOutValue;
	      ELSE
	        IF #track THEN
	          // output has same value as input
	          #tempOutv := #autoValue;
	        ELSE
	          // REGULAR FUNCTION
	          // Negativ range
	          IF #statPrevOutputValue < #ZERO_INT THEN
	            IF #statPrevOutputValue > #autoValue THEN
	              // limited rate of change
	              #tempVar := #statPrevOutputValue - #setNegUpRateLim * #tempCycleReal;
	              IF #autoValue < #tempVar THEN
	                // Setpoint not reached yet
	                // set notification for up rate limit in neg range
	                #tempNegUp := TRUE;
	                #tempOutv := #tempVar;
	              END_IF;
	            ELSE
	              IF #setNegDownRateLim = #ZERO_REAL THEN
	                // set notification for down rate limit in neg range
	                #tempNegDown := TRUE;
	                IF #autoValue <= #ZERO_REAL THEN
	                  #tempOutv := #autoValue;
	                ELSE
	                  #tempOutv := #ZERO_REAL;
	                END_IF;
	              ELSE
	                IF #autoValue <= #ZERO_REAL THEN
	                  // limited rate of change
	                  #tempVar := #statPrevOutputValue + #setNegDownRateLim * #tempCycleReal;
	                  IF #autoValue > #tempVar THEN
	                    // set notification for down rate limit in neg range
	                    #tempNegDown := TRUE;
	                    #tempOutv := #tempVar;
	                  END_IF;
	                ELSE
	                  // changeover between neg. and pos. range
	                  // period till zero-crossing
	                  #tempVar := - #statPrevOutputValue / #setNegDownRateLim;
	                  
	                  IF #tempVar <= #tempCycleReal THEN
	                    // period till zero-crossing shorten than sample time
	                    // limited rate of change
	                    #tempVar := (#tempCycleReal - #tempVar) * #setPosUpRateLim;
	                    
	                    IF #autoValue > #tempVar THEN
	                      // set notification for rate limit 
	                      #tempNegDown := FALSE;
	                      #tempPosUp := TRUE;
	                      #tempOutv := #tempVar;
	                    END_IF;
	                  ELSE
	                    // set notification for rate limit
	                    #tempNegDown := TRUE;
	                    #tempPosUp := FALSE;
	                    #tempOutv := #statPrevOutputValue + #tempCycleReal * #setNegDownRateLim;
	                  END_IF;
	                END_IF;
	              END_IF;
	            END_IF;
	          ELSE
	            // Positiv range + 0
	            IF #statPrevOutputValue < #autoValue THEN
	              // limited rate of change
	              #tempVar := #statPrevOutputValue + #setPosUpRateLim * #tempCycleReal;
	              IF #autoValue > #tempVar THEN
	                // set notification for up rate limit in pos range
	                #tempPosUp := TRUE;
	                #tempOutv := #tempVar;
	              END_IF;
	            END_IF;
	            
	            IF #statPrevOutputValue >= #autoValue THEN
	              IF #setPosDownRateLim = #ZERO_REAL THEN
	                // set notification for down rate limit in pos range
	                #tempPosDown := TRUE;
	                IF #autoValue >= #ZERO_REAL THEN
	                  #tempOutv := #autoValue;
	                ELSE
	                  #tempOutv := #ZERO_REAL;
	                END_IF;
	              ELSE
	                IF #autoValue >= #ZERO_REAL THEN
	                  // limited rate of change
	                  #tempVar := #statPrevOutputValue - #setPosDownRateLim * #tempCycleReal;
	                  IF #autoValue < #tempVar THEN
	                    // set notification for up rate limit in pos range
	                    #tempPosDown := TRUE;
	                    #tempOutv := #tempVar;
	                  END_IF;
	                ELSE  // changeover between pos. and neg. range
	                  // period till zero-crossing
	                  #tempVar := #statPrevOutputValue / #setPosDownRateLim;
	                  
	                  IF #tempVar <= #tempCycleReal THEN
	                    // limited rate of change
	                    #tempVar := - (#tempCycleReal - #tempVar) * #setNegUpRateLim;
	                    IF #autoValue < #tempVar THEN
	                      // set notification for rate limit
	                      #tempPosDown := False;
	                      #tempNegUp := TRUE;
	                      #tempOutv := #tempVar;
	                    END_IF;
	                  ELSE
	                    // set notification for rate limit
	                    #tempPosDown := TRUE;
	                    #tempNegUp := FALSE;
	                    #tempOutv := #statPrevOutputValue - #tempCycleReal * #setPosDownRateLim;
	                  END_IF;
	                END_IF;
	              END_IF;
	            END_IF;
	          END_IF;
	        END_IF;
	      END_IF;
	      
	      // high/low level limitation
	      IF #tempOutv >= #setHighLim THEN
	        #tempHighLim := TRUE;
	        IF NOT #statManOp THEN
	          #tempOutv := #setHighLim;
	          // correct up rate limit notification
	          IF #tempOutv - #statPrevOutputValue < #setPosUpRateLim * #tempCycleReal THEN
	            #tempPosUp := FALSE;
	          END_IF;
	        END_IF;
	      ELSE
	        IF #tempOutv <= #setLowLim THEN
	          #tempLowLim := TRUE;
	          IF NOT #statManOp THEN
	            #tempOutv := #setLowLim;
	            // correct up rate limit notification  
	            IF #statPrevOutputValue - #tempOutv < #setNegUpRateLim * #tempCycleReal THEN
	              #tempNegUp := FALSE;
	            END_IF;
	          END_IF;
	        ELSE
	          // reset manual mode flag when tempOutv between upper and lower limit
	          #statManOp := FALSE;
	        END_IF;
	      END_IF;
	    END_IF;
	  END_IF;
	  
	  #statPrevOutputValue := #tempOutv;
	END_REGION
	
	REGION writting to outputs
	  #error := FALSE;
	  #status := #STATUS_FINISHED_NO_ERROR;
	  #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;
	  
	  #outputValue := #tempOutv;
	  #posUpRateLim := #tempPosUp;
	  #posDownRateLim := #tempPosDown;
	  #negUpRateLim := #tempNegUp;
	  #negDownRateLim := #tempNegDown;
	  #highLim := #tempHighLim;
	  #lowLim := #tempLowLim;
	  
	  // ENO mechanism is not used
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION_BLOCK

