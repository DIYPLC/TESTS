TYPE "LGF_typeDiagnostics"
TITLE = LGF_typeDiagnostics
VERSION : 0.1
//Diagnostic structure to store and transfer diagnostic information from blocks through the interface.
   STRUCT
      status { ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Status of the Block or error identification when error occurred
      subfunctionStatus { ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Status or return value of called FB's, FC's and system blocks
      stateNumber { ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // State in the state machine of the block where the error occurred
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "LGF_FileDelete"
TITLE = LGF_FileDelete
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'Simatic Systems Support'
FAMILY : LGF
NAME : LGF_FileDelete
//This function block deletes a file that is stored on the memory card of the PLC (SMC) in the `UserFiles` folder.
   VAR_INPUT 
      execute : Bool;   // Rising edge starts file delete
      fileName : String;   // Name of file including path: `UserFiles/test.dat`
   END_VAR

   VAR_OUTPUT 
      done { ExternalWritable := 'False'} : Bool;   // TRUE: Commanded functionality has been completed successfully
      busy { ExternalWritable := 'False'} : Bool;   // TRUE: FB is not finished; new output values can be expected
      error { ExternalWritable := 'False'} : Bool;   // TRUE: An error occurred during the execution of the functionality
      fileDoesNotExist { ExternalWritable := 'False'} : Bool;   // True: The file or the path present at `fileName` does not exist  
      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;   // 16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error identification
      diagnostics { ExternalWritable := 'False'} : "LGF_typeDiagnostics";
   END_VAR

   VAR 
      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Internal function flags
         executePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Previous value of 'execute' input for edge detection
         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'done'
         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'busy'
         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'error'
         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "LGF_typeDiagnostics" := (#STATUS_NO_CALL, (), ());
         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "LGF_typeDiagnostics" := (#STATUS_NO_CALL, (), ());   // Empty diagnostics information (for initialization purposes only)
      END_STRUCT;
      instFileDelete {InstructionName := 'FileDelete'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileDelete;   // File delete instance
      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;   // State in the state machine of the FB
   END_VAR

   VAR_TEMP 
      tempExecute : Bool;   // Temporary variable for input 'execute'
      tempExitStateLoop : Bool;   // Set to TRUE: leave loop from state machine after run trough
      tempResult : Word;   // Temporary variable to store results of sub function call and do error handling if error occurs
      tempBufferPosition : DInt;   // Temporary variable for serialization / for the prefix check
      tempPathPrefix : String;   // Temporary variable for filepath prefix
   END_VAR

   VAR CONSTANT 
      PATH_PREFIX : String := 'UserFiles/';   // Path prefix needed in front of the file name
      FILE_DELETE_PATH_NAME_NOT_EXIST : Word := 16#8091;   // Error: The file or the path present at `fileName`dose not exist  
      FILE_DELETE_FILE_NOT_EXIST : Word := 16#8092;   // Error: The file at `fileName`dose not exist in the path
      FB_STATE_NO_PROCESSING : DInt := 0;   // FB state: No processing
      FB_STATE_INIT : DInt := 1;   // FB state: Init
      FB_STATE_FILE_DELETE : DInt := 2;   // FB state: Delete file
      STATUS_EXECUTION_FINISHED : Word := 16#0000;   // Execution finished without errors
      STATUS_NO_CALL : Word := 16#7000;   // No job being currently processed
      STATUS_FIRST_CALL : Word := 16#7001;   // First call after incoming new job (rising edge 'execute')
      STATUS_SUBSEQUENT_CALL : Word := 16#7002;   // Subsequent call during active processing without further details
      ERR_UNDEFINED_STATE : Word := 16#8600;   // Error due to an undefined state in state machine
      "- - - Application Error codes" : Word;
      ERR_FILE_PATH : Word := 16#8401;   // Error: File path error: File path must start with 'UserFiles/'.
      ERR_FILE_DELETE_INIT : Word := 16#8604;   // Error: Read file from SMC - see `diagnostics.subFunctionStatus`
      ERR_FILE_DELETE : Word := 16#8605;   // Error: Read file from SMC - see `diagnostics.subFunctionStatus`
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //================================================================================
	  // (C)Copyright Siemens 2025
	  //--------------------------------------------------------------------------------
	  // Library:       LGF (Library General Functions) 
	  // Tested with:   S7-1510SP-F
	  // Engineering:   TIA Portal V15
	  // Restrictions:  ---
	  // Requirements:  S7-1500/S7-1500T FW 2.5
	  // Functionality: This function block offers deleting a file stored on the PLC's memory card (SMC) in the folder `UserFiles`.
	  //--------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge        | Changes applied
	  //----------|------------|-------------------------|------------------------------
	  // 01.00.00 | 29.04.2025 | Simatic Systems Support | First released version
	  //================================================================================
	END_REGION
	
	REGION DESCRIPTION
	  (/*
	With the function `LGF_FileDelete` a file can be deleted from the SIMATIC Memory Card (SMC). The file name must always be specified in full together with the folder name and the file extension in the following format: `UserFiles/test.dat`.
	*/)
	END_REGION DESCRIPTION
	
	REGION TRIGGERING
	  #tempExecute := #execute; // Work with temporary value / create process image
	  IF (#tempExecute = TRUE) AND (#statInternal.executePrevious = FALSE) // Check if FB is triggered
	    // FB shall finish current job before new job can be started with rising edge of execute
	    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)
	  THEN // First call; initialize FB
	    #statInternal.done := FALSE;
	    #statInternal.busy := TRUE;
	    #statInternal.error := FALSE;
	    
	    #statMainState := #FB_STATE_INIT; // State machine - start processing
	    // Initialize functionality: reset of variables, diagnostics, etc.
	    #statInternal.diagnostics := #statInternal.emptyDiagnostics;
	    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;
	    #diagnostics := #statInternal.emptyDiagnostics;
	    
	    // Initialize functionality: call subsidiary FBs with FALSE
	    #instFileDelete(REQ := FALSE);
	    
	  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN
	    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;
	  END_IF;
	  
	  // Edge detection 'execute' input
	  #statInternal.executePrevious := #tempExecute;
	END_REGION TRIGGERING
	
	IF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce "system load"
	  RETURN;
	END_IF;
	
	REGION STATE_MACHINE
	  // if one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;
	  REPEAT
	    // reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop
	    #tempExitStateLoop := TRUE;
	    
	    // State machine of FB
	    CASE #statMainState OF
	      #FB_STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)
	        ;
	        
	      #FB_STATE_INIT:
	        REGION Init
	          REGION Verify File Path
	            #tempPathPrefix := #PATH_PREFIX;
	            
	            FOR #tempBufferPosition := 1 TO DINT_TO_INT(LEN(#tempPathPrefix)) DO
	              IF #fileName[#tempBufferPosition] <> #tempPathPrefix[#tempBufferPosition] THEN
	                // Characters arenÄt identiacal
	                #statInternal.diagnostics.status := #ERR_FILE_PATH;
	                #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#tempBufferPosition);
	                // stop execution and leave block
	                EXIT;
	              END_IF;
	            END_FOR;
	            
	            IF #statInternal.diagnostics.status.%X15 THEN
	              EXIT;
	            END_IF;
	          END_REGION
	          
	          // next state
	          #statMainState := #FB_STATE_FILE_DELETE;
	        END_REGION
	        
	      #FB_STATE_FILE_DELETE:
	        REGION File handling
	          // set file handler request to true
	          #instFileDelete(REQ  := TRUE,
	                          Name := #fileName);
	          
	          IF #instFileDelete.Error THEN
	            #statInternal.diagnostics.status := #ERR_FILE_DELETE;
	            #statInternal.diagnostics.subfunctionStatus := #instFileDelete.Status;
	            // stop execution and leave block
	            EXIT;
	            
	          ELSIF #instFileDelete.Done THEN
	            // next state switched by status
	            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;
	            #statInternal.diagnostics.subfunctionStatus := 16#0000;
	            
	          ELSE
	            ; // nothing to do, just proceed
	          END_IF;
	        END_REGION
	        
	      ELSE // Undefined state in state machine reached
	        #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;
	    END_CASE;
	    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;
	    // check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP
	  UNTIL (TRUE = #tempExitStateLoop)
	  END_REPEAT;
	END_REGION STATE_MACHINE
	
	REGION OUTPUTS
	  // Write outputs
	  IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN // Execution finished without errors
	    #statInternal.done := TRUE;
	    #statInternal.busy := FALSE;
	    #statInternal.error := FALSE;
	    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to "no processing"
	    
	  ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)
	    #statInternal.done := FALSE;
	    #statInternal.busy := FALSE;
	    #statInternal.error := TRUE;
	    // Write diagnostics
	    #statInternal.diagnostics.stateNumber := #statMainState;
	    #diagnostics := #statInternal.diagnostics;
	    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to "no processing"
	    
	  ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE)) THEN // Reset outputs
	    #statInternal.done := FALSE;
	    #statInternal.busy := FALSE;
	    #statInternal.error := FALSE;
	    #statInternal.diagnostics.status := #STATUS_NO_CALL;
	  END_IF;
	  
	  // Write static values to outputs
	  #done := #statInternal.done;
	  #busy := #statInternal.busy;
	  #error := #statInternal.error;
	  #status := #statInternal.diagnostics.status;
	  
	  #fileDoesNotExist := TRUE
	  AND #statInternal.diagnostics.status = #ERR_FILE_DELETE
	  AND (FALSE
	  OR #statInternal.diagnostics.subfunctionStatus = #FILE_DELETE_PATH_NAME_NOT_EXIST
	  OR #statInternal.diagnostics.subfunctionStatus = #FILE_DELETE_FILE_NOT_EXIST
	  )
	  ;
	  
	  ENO := #statInternal.error;
	END_REGION OUTPUTS
	
END_FUNCTION_BLOCK

