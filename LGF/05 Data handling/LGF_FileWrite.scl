TYPE "LGF_typeDiagnostics"
TITLE = LGF_typeDiagnostics
VERSION : 0.1
//Diagnostic structure to store and transfer diagnostic information from blocks through the interface.
   STRUCT
      status { ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Status of the Block or error identification when error occurred
      subfunctionStatus { ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Status or return value of called FB's, FC's and system blocks
      stateNumber { ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // State in the state machine of the block where the error occurred
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "LGF_FileWrite"
TITLE = LGF_FileWrite
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'Siemens SIMATIC Systems Support'
FAMILY : LGF
NAME : LGF_FileWrite
//This function block offers writing data as binary / serialized data stream to a file which is then stored on the PLC's memory card in the folder `UserFiles`.
   VAR_INPUT 
      execute : Bool;   // Rising edge starts file write once
      clearBufferBefore : Bool;   // TRUE: Buffer would be cleared with 16#00 Byte before writing the data
      fileName : String;   // Name of file including path: `UserFiles/test.dat`
   END_VAR

   VAR_OUTPUT 
      done { ExternalWritable := 'False'} : Bool;   // TRUE: Commanded functionality has been completed successfully
      busy { ExternalWritable := 'False'} : Bool;   // TRUE: FB is not finished and new output values can be expected
      error { ExternalWritable := 'False'} : Bool;   // TRUE: An error occurred during the execution of the FB
      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;   // 16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error identification
      dataLength { ExternalWritable := 'False'} : DInt;   // Data length written to file (serialized length of `data`)
      diagnostics { ExternalWritable := 'False'} : "LGF_typeDiagnostics";
   END_VAR

   VAR_IN_OUT 
      bufferByteArray : Array[*] of Byte;   // Byte array buffer for read / write from / to file
      data : Variant;   // Data set to write into file
   END_VAR

   VAR 
      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Internal function flags
         executePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Old value of 'execute' input for edge detection
         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'done'
         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'busy'
         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value for output 'error'
         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "LGF_typeDiagnostics" := (#STATUS_NO_CALL, (), ());
         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "LGF_typeDiagnostics" := (#STATUS_NO_CALL, (), ());   // Empty diagnostics information (for initialization purposes only)
      END_STRUCT;
      instFileWrite {InstructionName := 'FileWriteC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileWriteC;   // File write instance
      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;   // State in the state machine of the FB
      statParameterDataIsByteArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Store type of Parameter, in case of "ByteArray" -->  serialize isn't needed....
      statAsynchronusMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set this tag to TRUE if asynchronous mode is desired
      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Size of buffer array
      statLengthData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;   // Size of datapoint given at `data`
      statLengthFile { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;   // Size of datapoint given at `instFileWrite`
   END_VAR

   VAR_TEMP 
      tempExecute : Bool;   // Temporary value for input 'execute'
      tempExitStateLoop : Bool;   // Set to TRUE: leave loop from state machine after run trough
      tempResult : Word;   // Temp tag to store results of sub function call and do error handling if error occurs
      tempBufferPosition : DInt;   // Temp tag used for serialization
      tempPathPrefix : String;   // Temp tag for filepath prefix
   END_VAR

   VAR CONSTANT 
      PATH_PREFIX : String := 'UserFiles/';   // Path prefix needed in front of the file name
      EMPTY_BYTE : Byte := 16#00;   // Empty byte to initialize the buffer
      FB_STATE_NO_PROCESSING : DInt := 0;   // FB state: No processing
      FB_STATE_INIT : DInt := 1;   // FB state: Init
      FB_STATE_PARAMETER : DInt := 2;   // FB state: Process parameter
      FB_STATE_FILE_WRITE : DInt := 3;   // FB state: Write to file
      STATUS_EXECUTION_FINISHED : Word := 16#0000;   // Execution finished without errors
      STATUS_NO_CALL : Word := 16#7000;   // No job being currently processed
      STATUS_FIRST_CALL : Word := 16#7001;   // First call after incoming new job (rising edge 'execute')
      STATUS_SUBSEQUENT_CALL : Word := 16#7002;   // Subsequent call during active processing without further details
      ERR_UNDEFINED_STATE : Word := 16#8600;   // Error due to an undefined state in state machine
      "- - - Application Error codes" : Word;
      ERR_BUFFER_LOWERBOUND : Word := 16#8201;   // Error: Buffer array lower bound  Lower bound has to be 0
      ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY : Word := 16#8202;   // Error: Buffer size less than needed size for data
      ERR_FILE_PATH : Word := 16#8401;   // Error: File path error: File path has to start with 'UserFiles/'.
      ERR_MOVE_BLK_VARIANT : Word := 16#8601;   // Error: Move block variant (data to buffer) - see `diagnostics.subFunctionStatus`
      ERR_DATA_SERIALIZE : Word := 16#8603;   // Error: Serialize data - see `diagnostics.subFunctionStatus`
      ERR_FILE_WRITE_INIT : Word := 16#8604;   // Error: Write file to SMC - see `diagnostics.subFunctionStatus`
      ERR_FILE_WRITE : Word := 16#8605;   // Error: Write file to SMC - see `diagnostics.subFunctionStatus`
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //================================================================================
	  // SIEMENS AG
	  // (c)Copyright 2017 All Rights Reserved
	  //--------------------------------------------------------------------------------
	  // Library:       LGF (Library General Functions)
	  // Tested with:   S7-1510SP-F
	  // Engineering:   TIA Portal V15
	  // Restrictions:  ---
	  // Requirements:  S7-1500/S7-1500T FW 2.5
	  // Functionality: This function block offers writing data as binary / serialized data stream
	  //                to a file which is then stored on the PLC's memory card in the folder `UserFiles`.
	  //--------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge        | Changes applied
	  //----------|------------|-------------------------|------------------------------
	  // 01.00.00 | 19.02.2023 | Simatic Systems Support | First released version
	  // 01.01.00 | 29.04.2025 | Simatic Systems Support | Insert parameter `clearBufferBefore` to clear buffer befor serializing the data
	  //================================================================================
	END_REGION
	
	REGION DESCRIPTION
	  (/*
	With the function `LGF_FileWrite` the data budget of a variable can be written to `data` in a file. For writing the data it is necessary to serialize it, which the function already takes from the user.  
	For serialization an external buffer in the form of a byte array must be connected which can take up the data quantity, if the buffer is too small an error is output.
	
	The file name must always be specified in full together with the folder name and the file extension in the following format: `UserFiles/test.dat`.
	
	---
	
	Note
	:    The file extension (here e.g. `dat`) can be freely selected or omitted, it is useful for external processing to indicate the format of the file to the user.
	:    A file extension in the file name has no influence on the content of the file as well as its formatting, to provide the data in an appropriate file format is up to the user.
	
	---
	
	Warning
	:    The SMC (SIMATIC Memory Card) is a flash memory with finite write cycles.
	:    A high frequent write access therefore also affects the lifetime of the SMC!
	*/)
	END_REGION DESCRIPTION
	
	REGION TRIGGERING
	  #tempExecute := #execute; // Work with temporary value / create process image
	  IF (#tempExecute = TRUE) AND (#statInternal.executePrevious = FALSE) // Check if FB is triggered
	    // FB shall finish current job before new job can be started with rising edge OF #execute
	    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)
	  THEN // First call; initialize FB
	    #statInternal.done := FALSE;
	    #statInternal.busy := TRUE;
	    #statInternal.error := FALSE;
	    
	    #statMainState := #FB_STATE_INIT; // State machine - start processing
	    // Initialize functionality: reset of variables, diagnostics, etc.
	    #statInternal.diagnostics := #statInternal.emptyDiagnostics;
	    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;
	    #diagnostics := #statInternal.emptyDiagnostics;
	    
	    // Initialize functionality: call subsidiary FBs with FALSE
	    #instFileWrite(REQ := FALSE);
	    
	  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN
	    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;
	  END_IF;
	  
	  // Edge detection 'execute' input
	  #statInternal.executePrevious := #tempExecute;
	END_REGION TRIGGERING
	
	IF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce "system load"
	  RETURN;
	END_IF;
	
	REGION STATE_MACHINE
	  // if one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;
	  REPEAT
	    // reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop
	    #tempExitStateLoop := TRUE;
	    
	    // State machine of FB
	    CASE #statMainState OF
	      #FB_STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)
	        ;
	        
	      #FB_STATE_INIT:
	        REGION Init
	          REGION Verify File Path
	            #tempPathPrefix := #PATH_PREFIX;
	            
	            FOR #tempBufferPosition := 1 TO DINT_TO_INT(LEN(#tempPathPrefix)) DO
	              IF #fileName[#tempBufferPosition] <> #tempPathPrefix[#tempBufferPosition] THEN
	                // Characters arenÄt identiacal
	                #statInternal.diagnostics.status := #ERR_FILE_PATH;
	                #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#tempBufferPosition);
	                // stop execution and leave block
	                EXIT;
	              END_IF;
	            END_FOR;
	            
	            IF #statInternal.diagnostics.status.%X15 THEN
	              EXIT;
	            END_IF;
	          END_REGION
	          
	          REGION Verify buffer boundary
	            // check buffer size
	            // check lower boundary
	            #tempResult := DINT_TO_WORD(LOWER_BOUND(ARR := #bufferByteArray, DIM := 1));
	            
	            IF 0 <> #tempResult THEN
	              // ERROR: buffer lowerbound has to be 0
	              #statInternal.diagnostics.status := #ERR_BUFFER_LOWERBOUND;
	              #statInternal.diagnostics.subfunctionStatus := #tempResult;
	              // stop execution and leave block
	              EXIT;
	            ELSE
	              ; // nothing to do, just proceed
	            END_IF;
	            
	            // get upper boundary and calc size of buffer
	            #statBufferSize := UPPER_BOUND(ARR := #bufferByteArray, DIM := 1) + 1;
	          END_REGION
	          
	          // verify parameter data types
	          REGION Verify parameter data types
	            // check type of Parameter attached to IN/OUT
	            // if Array proceed here, Array limits checked by move block variant
	            IF IS_ARRAY(#data) AND TypeOfElements(#data) = Byte THEN
	              // data type match - nothing to do
	              #statParameterDataIsByteArray := TRUE;
	              // get array size
	              #statLengthData := UDINT_TO_DINT(CountOfElements(#data));
	              
	              // verify if buffer is big enough to store data
	              IF #statBufferSize < #statLengthData THEN
	                // ERROR: buffer array is to small for data array
	                #statInternal.diagnostics.status := #ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY;
	                #statInternal.diagnostics.subfunctionStatus := 16#0000;
	                // stop execution and leave block
	                EXIT;
	              ELSE
	                ; // nothing to do, just proceed
	              END_IF;
	              
	            ELSE
	              #statParameterDataIsByteArray := FALSE;
	              #statLengthData := 0;
	            END_IF;
	          END_REGION
	          
	          REGION File handler init
	            // init file write with false
	            #instFileWrite(REQ := FALSE);
	            
	            IF #instFileWrite.Error THEN
	              #statInternal.diagnostics.status := #ERR_FILE_WRITE_INIT;
	              #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;
	              // stop execution and leave block
	              EXIT;
	            ELSE //IF TRUE = #instFileWriteC.Done THEN
	              // next state
	              #statMainState := #FB_STATE_PARAMETER;
	              // ASYNCRONUS - set to true:
	              #tempExitStateLoop := #statAsynchronusMode;
	            END_IF;
	          END_REGION
	        END_REGION
	        
	      #FB_STATE_PARAMETER:
	        REGION Parameter handling
	          // if paramter is byte array - just copy
	          IF #statParameterDataIsByteArray THEN
	            // copy paramter array into buffer array
	            #tempResult := INT_TO_WORD(
	                                       MOVE_BLK_VARIANT(SRC := #data,
	                                                        COUNT := DINT_TO_UDINT(#statLengthData),
	                                                        SRC_INDEX := DINT#0,
	                                                        DEST_INDEX := DINT#0,
	                                                        DEST => #bufferByteArray)
	            );
	            
	            // check if move parameter structure was successful, otherwise set ERROR
	            IF 16#0000 <> #tempResult THEN
	              #statInternal.diagnostics.status := #ERR_MOVE_BLK_VARIANT;
	              #statInternal.diagnostics.subfunctionStatus := #tempResult;
	              // stop execution and leave block
	              EXIT;
	              
	            ELSE
	              // next state
	              #statMainState := #FB_STATE_FILE_WRITE;
	              // ASYNCRONUS - set to true:
	              #tempExitStateLoop := #statAsynchronusMode;
	            END_IF;
	            
	            // else if parameter is NOT byte array - SERIALZE Data
	          ELSE
	            // Clear buffer before writing the data into the file
	            // This avoids unintended content inside the binary file
	            IF #clearBufferBefore THEN
	              FILL_BLK(IN    := #EMPTY_BYTE,
	                       COUNT := DINT_TO_UDINT(#statBufferSize),
	                       OUT   => #bufferByteArray[0]);
	            END_IF;
	            
	            // init buffer size/position pointer
	            #tempBufferPosition := 0;
	            // serialize data into buffer
	            #tempResult := INT_TO_WORD(
	                                       Serialize(SRC_VARIABLE := #data,
	                                                 DEST_ARRAY => #bufferByteArray,
	                                                 POS := #tempBufferPosition)
	            );
	            
	            // check if serialize parameter structure was successful, otherwise set ERROR
	            IF 16#0000 <> #tempResult THEN
	              #statInternal.diagnostics.status := #ERR_DATA_SERIALIZE;
	              #statInternal.diagnostics.subfunctionStatus := #tempResult;
	              // stop execution and leave block
	              EXIT;
	            ELSE
	              // after serialize, set array size pointer to numer of serialized elements
	              #statLengthData := #tempBufferPosition;
	              // next state
	              #statMainState := #FB_STATE_FILE_WRITE;
	              // ASYNCRONUS - set to true:
	              #tempExitStateLoop := #statAsynchronusMode;
	            END_IF;
	          END_IF;
	        END_REGION
	        
	      #FB_STATE_FILE_WRITE:
	        REGION File handling
	          // set file handler request to true
	          #instFileWrite(REQ    := TRUE,
	                         Name   := #fileName,
	                         Offset := UDINT#0,
	                         Length := DINT_TO_UDINT(#statLengthData),
	                         Data   := #bufferByteArray);
	          
	          IF #instFileWrite.Error THEN
	            #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);
	            #statInternal.diagnostics.status := #ERR_FILE_WRITE;
	            #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;
	            // stop execution and leave block
	            EXIT;
	            
	          ELSIF #instFileWrite.Done THEN
	            #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);
	            // next state switched by status
	            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;
	            #statInternal.diagnostics.subfunctionStatus := 16#0000;
	            
	          ELSE
	            ; // nothing to do, just proceed
	          END_IF;
	        END_REGION
	        
	      ELSE // Undefined state in state machine reached
	        #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;
	        #statInternal.diagnostics.subfunctionStatus := 16#0000;
	    END_CASE;
	    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;
	    // check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP
	  UNTIL (TRUE = #tempExitStateLoop)
	  END_REPEAT;
	END_REGION STATE_MACHINE
	
	REGION OUTPUTS
	  // Write outputs
	  IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN // Execution finished without errors
	    #statInternal.done := TRUE;
	    #statInternal.busy := FALSE;
	    #statInternal.error := FALSE;
	    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to "no processing"
	    
	  ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)
	    #statInternal.done := FALSE;
	    #statInternal.busy := FALSE;
	    #statInternal.error := TRUE;
	    // Write diagnostics
	    #statInternal.diagnostics.stateNumber := #statMainState;
	    #diagnostics := #statInternal.diagnostics;
	    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to "no processing"
	    
	  ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE)) THEN // Reset outputs
	    #statInternal.done := FALSE;
	    #statInternal.busy := FALSE;
	    #statInternal.error := FALSE;
	    #statInternal.diagnostics.status := #STATUS_NO_CALL;
	    #statLengthData := 0;
	    #statLengthFile := 0;
	  END_IF;
	  
	  // Write static values to outputs
	  #done := #statInternal.done;
	  #busy := #statInternal.busy;
	  #error := #statInternal.error;
	  #status := #statInternal.diagnostics.status;
	  
	  #dataLength := #statLengthData;
	  ENO := #statInternal.error;
	END_REGION OUTPUTS
	
END_FUNCTION_BLOCK

