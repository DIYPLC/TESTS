FUNCTION_BLOCK "LGF_ShellSort_LReal"
TITLE = LGF_ShellSort_LReal
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Industry_Support
FAMILY : LGF
NAME : LGF_ShellSort_LReal
//This block sorts an array of type `LReal` with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.
   VAR_INPUT 
      sortDirection : Bool;   // FALSE: Sort ascending; TRUE: Sort descending
   END_VAR

   VAR_OUTPUT 
      error { ExternalWritable := 'False'} : Bool;   // FALSE: No error  TRUE: An error occurred during the execution of the FB
      status { ExternalWritable := 'False'} : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
   END_VAR

   VAR_IN_OUT 
      "array" : Array[*] of LReal;   // Array to be sorted
   END_VAR

   VAR 
      tempArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#MAX_ARRAY_ELEMENTS] of LReal;   // Temporary array for sorting purposes
   END_VAR

   VAR_TEMP 
      tempLowerLimit : DInt;   // Lower limit of input array
      tempUpperLimit : DInt;   // Upper limit of input array
      tempNoOfElements : DInt;   // Number of elements in array
      tempGap : DInt;   // Selected gap size
      tempLoopIndex : DInt;   // FOR loop index
      tempExchangeIndex : DInt;   // Index of temporary exchange value
      tempExchangeVariable : LReal;   // Temporary exchange value
      tempArrayOffset : DInt;   // Index offset of temporary array (e.g. in case of negative index in array[*])
   END_VAR

   VAR CONSTANT 
      ARRAY_FIRST_DIMENSION : UInt := 1;   // Input array first dimension
      ARRAY_START_INDEX : UInt := 1;   // Temp array start index
      SINGLE_ARRAY_ELEMENT : DInt := 1;   // Array containing just one element
      GAP_INIT : Int := 1;   // Gap size initialization
      GAP_THRESHOLD : Int := 1;   // Gap threshold for cycle termination
      GAP_RATIO : DInt := 3;   // Maximal gap ratio
      INCREMENT : Int := 1;   // Increment value ONE
      ELEMENTS_COUNT_CORRECTION : DInt := 1;   // Array counter size correction (0-based counting)
      MAX_ARRAY_ELEMENTS : Int := 1000;   // Max array elements allowed
      STATUS_NO_ERROR : Word := 16#0000;   // Status: Execution finished without errors
      ERR_NO_ARRAY : Word := 16#8200;   // Error: Actual parameter at the `array` input has only one element.
      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;   // Error: Actual parameter at the `array` input has too many elements (maximum is 1000).
   END_VAR


BEGIN
	REGION Block info header
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_ShellSort_DInt
	  // Comment/Function: This block sorts an array with any number of elements (max. 1000)
	  //                   in ascending or descending order and returns the sorted version of the array in the same variable.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU 1515F-2 PN FW:V2.6
	  // Engineering:      TIA Portal V15.1 Update 2
	  // Restrictions:     ENO disabled - error handling done with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 19.08.2015  Siemens Industry Online Support
	  //                      First released version
	  // 01.01.00 19.05.2016  Siemens Industry Online Support
	  //                      New function: reverse sort
	  // 01.01.01 02.01.2017  Siemens Industry Online Support
	  //                      Upgrade: TIA Portal V14 Update 1
	  // 01.01.02 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.01.03 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 02.00.00 29.01.2019  Siemens Industry Online Support
	  //                      Output "done" removed (not necessary, because only one cycle)
	  // 02.00.01 15.10.2019  Simatic Systems Support
	  //                      Code refactoring, comments added,
	  //                      change data type from Real to LReal
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 15.02.2021  Simatic Systems Support
	  //                      Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	The block sorts according to the shell sort procedure. Note that the execution time of the block depends significantly on how many elements the array to be sorted has. The overview below shows several measured values of the block depending on the number of array elements.
	
	Average steps needed for execution: $ \mathcal{O}( n \cdot \log (n)^2 ) $
	
	Table: Execution times of the block `LGF_ShellSort…`
	
	| Number of array elements  | S7-1212C DC/DC/DC | S7-1516-3 PN/DP |
	|-----|-----|-----|
	| 100 | approx. 11-16 ms | approx. 1-2 ms |
	| 1000 | approx. 185-205 ms | approx. 10-12 ms |
	
	Note
	:    The block is executed synchronously and is not split over several PLC cycles. Thus the execution time has a direct effect on the PLC cycle time. Note this behavior for your project of the controller used and adjust the monitoring time of the controller if necessary.
	*/)
	END_REGION DESCRIPTION
	
	REGION Special description
	  // Space note: If you wish to reduce the space of this block, you may reduce the
	  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose
	  // It is not recommended to increase the size significantly.
	END_REGION
	
	REGION Initialization and input data processing
	  // Input array size calculation
	  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);
	  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);
	  
	  // Array elements calculation
	  // (for example: 6 - 2 = 4; but real number of elements is 5)
	  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;
	  
	  // Shift array index to range 1..MAX_ARRAY_ELEMENTS
	  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;
	  
	  // Check whether the array contains less than the maximum possible amount of elements
	  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN
	    #error := true;
	    #status := #ERR_TOO_MANY_ELEMENTS;
	    RETURN;
	  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN
	    // If there are 0 elements in the array, set status to "Error: Parameter is an empty array"
	    #error := true;
	    #status := #ERR_NO_ARRAY;
	    RETURN;
	  END_IF;
	END_REGION
	
	REGION Sorting
	  // Read the elements of the incoming array and write into the local array
	  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO
	    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];
	  END_FOR;
	  
	  REGION Shell sort algorithm
	    #tempGap := #GAP_INIT;
	    
	    // Evaluation of the maximal gap size
	    REPEAT
	      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;
	    UNTIL #tempGap > #tempNoOfElements END_REPEAT;
	    
	    REPEAT
	      #tempGap := #tempGap / #GAP_RATIO;
	      
	      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO
	        #tempExchangeVariable := #tempArray[#tempLoopIndex];
	        #tempExchangeIndex := #tempLoopIndex;
	        
	        // sort descending 
	        IF #sortDirection THEN
	          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO
	            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];
	            #tempExchangeIndex := #tempExchangeIndex - #tempGap;
	            
	            IF (#tempExchangeIndex <= #tempGap) THEN
	              EXIT;
	            END_IF;
	          END_WHILE;
	          
	          // sort ascending
	        ELSE
	          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO
	            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];
	            #tempExchangeIndex := #tempExchangeIndex - #tempGap;
	            
	            IF (#tempExchangeIndex <= #tempGap) THEN
	              EXIT;
	            END_IF;
	          END_WHILE;
	        END_IF;
	        
	        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;
	      END_FOR;
	      
	    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;
	  END_REGION
	  
	  // Write the elements of the local array back to the inOut array
	  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO
	    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];
	  END_FOR;
	  
	  // Set "No error" status
	  #error := false;
	  #status := #STATUS_NO_ERROR;
	  
	  // no error handling needed
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION_BLOCK

