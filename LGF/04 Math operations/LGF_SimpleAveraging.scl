FUNCTION_BLOCK "LGF_SimpleAveraging"
TITLE = LGF_SimpleAverage
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_FloatingAverage
//This function calculates a moving arithmetic mean from LReal values.  
//The method can be used to smooth data series; the values can be read in cyclically or triggered.
   VAR_INPUT 
      cyclicExecution : Bool;   // TRUE: cyclic operation, trigger not in use
      trigger : Bool;   // Rising edge: Read in `value` with every pulse at input `trigger`
      reset : Bool;   // TRUE: The block is reset and the calculation starts again.
      value : LReal;   // Value/s from which the moving average is to be determined.
      windowSize : USInt := 5;   // Window length for averaging in the range from 1..255
   END_VAR

   VAR_OUTPUT 
      average { ExternalWritable := 'False'} : LReal;   // Moving / Floating average
      overflow { ExternalWritable := 'False'} : Bool;   // TRUE: Overflow detected in the calculation
   END_VAR

   VAR 
      statValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Static variable for value input
      statAverage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;   // Static calculated average
      statWindowSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;   // Static windows size from previous scan
      statOverflow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Static value Overflow dedected
      statTriggerOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;   // Static value of trigger from previous scan. Used for edge detection.
   END_VAR

   VAR CONSTANT 
      ZERO_LREAL : LReal := 0.0;   // Zero constant in LReal format
      LGF_LREAL_MAX_NORM : LReal := 16#7FEF_FFFF_FFFF_FFFF;   // LReal / Double - maximum value in normalized format
      LGF_LREAL_MIN_NORM : LReal := 16#0010_0000_0000_0000;   // LReal / Double - minimum value in normalized format
   END_VAR


BEGIN
	REGION Block info header
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_SimpleAveraging
	  // Comment/Function: This function calculates a moving arithmetic mean value from LReal values.
	  //                   The method can be used to smooth data series, values can be read in cyclically or triggered.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU 1515F-2 PN FW:V2.6
	  // Engineering:      TIA Portal V15.1 Update 2
	  // Restrictions:     ENO disabled, forced to true - error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 18.07.2024 | Simatic Systems Support
	  //                       | First Release
	  //===============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	Note
	:    The block `LGF_SimpleAveraging` does not query the data type for the input parameter `value`. For data types other than LReal, either an implicit conversion is performed automatically or an error is generated during compilation.
	:    You can find further information in the Chapter “Overview of Data Type Conversion” in the Online Help section of the TIA Portal or under:
	:    https://support.industry.siemens.com/cs/ww/en/view/109773506/100611494667
	
	---
	
	The block calculates the (moving) average based on the set `windowSize`. If `windowSize` is set to $windowSize < 1$, the value is passed through without averaging.
	
	There are two options for reading the values:
	
	* With the `cyclicExecution` input, the values are read and calculated cyclically.
	* With the `Trigger` input, the values are read and calculated with each pulse.
	
	If the calculation reaches the value range limits of `LReal`, the output `overflow` is set.
	*/)
	END_REGION DESCRIPTION
	
	REGION Floating average calculation
	  // Copy commonly used data to temp variables
	  #statValue := #value;
	  
	  // Reset OR window size changes the calculation
	  IF #reset THEN
	    #statAverage := #ZERO_LREAL;
	    
	    // Triggered calculation OR cyclicly operation
	    // Positive edge detection for triggering of calculation
	  ELSIF FALSE
	    OR #cyclicExecution
	    OR #trigger AND NOT #statTriggerOld
	  THEN
	    IF #statWindowSize > 1 THEN
	      // Actual NEW = (previous * (averageNumber - 1) + actual) / averageNumber;
	      #statAverage := (#statAverage * (#statWindowSize - 1) + #statValue) / #statWindowSize;
	      #statOverflow := (ABS(#statValue) <> #ZERO_LREAL) AND (FALSE
	      OR ((#LGF_LREAL_MIN_NORM * #statWindowSize) > ABS(#statValue))
	      OR ((#LGF_LREAL_MAX_NORM / #statWindowSize) < ABS(#statValue))
	      );
	    ELSE
	      #statAverage := #statValue;
	      #statOverflow := FALSE;
	    END_IF;
	  END_IF;
	  #statTriggerOld := #trigger;
	  #statWindowSize := #windowSize;
	END_REGION
	
	REGION Outputs
	  #average := #statAverage;
	  #overflow := #statOverflow;
	  
	  // ENO mechanism is not used - forced to true
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION_BLOCK

