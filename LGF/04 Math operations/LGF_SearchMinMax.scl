FUNCTION "LGF_SearchMinMax" : Void
TITLE = LGF_SearchMinMax
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industries
FAMILY : LGF
NAME : LGF_SearchMinMax
//This function searches, in an array of the data type DInt, for the maximum and minimum value and the respective index in the array.
//
//The following data types of the array elements are supported:  
//Int, DInt, UInt, UDInt, USInt, SInt, and Real.
   VAR_INPUT 
      variableArray : Variant;   // Array in whose fields the maximum and minimum are searched
   END_VAR

   VAR_OUTPUT 
      minValue : Variant;   // Minimum value found in the array
      minValueIndex : DInt;   // Index of the minimum found value in the array.  The start index of the array plus `minValueIndex` results in the array index of the smallest value. The index starts with 0.
      maxValue : Variant;   // Maximum value found in the array
      maxValueIndex : DInt;   // Index of the maximum found value in the array.  The start index of the array plus `maxValueIndex` results in the array index of the smallest value. The index starts with 0.
      error : Bool;   // FALSE: No error  TRUE: An error occurred during the execution of the FB
      status : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
      subfunctionStatus : Word;   // Status or return value of called FB's, FC's and system blocks
   END_VAR

   VAR_TEMP 
      tempArrayEndIndex : DInt;   // Endindex of the input array =  arraysize - 1, as the loop traversing is zero based
      tempCounter : DInt;   // Loop iteration counter to travers trough the array
      tempSubfunctionErr : Int;   // Error code of subfunction
      tempArrayIndexMax : DInt;   // Current index number of the maximum found value
      tempArrayIndexMin : DInt;   // Current index number of the minimum found value
      tempActValueInt : Int;   // Int search: value of the current possition in the array
      tempMinInt : Int;   // Int search: current minimum found value
      tempMaxInt : Int;   // Int search: current maximum found value
      tempActValueUInt : UInt;   // UInt search: value of the current possition in the array
      tempMinUInt : UInt;   // UInt search: current minimum found value
      tempMaxUInt : UInt;   // UInt search: current maximum found value
      tempActValueDInt : DInt;   // DInt search: value of the current possition in the array
      tempMinDInt : DInt;   // DInt search: current minimum found value
      tempMaxDInt : DInt;   // DInt search: current maximum found value
      tempActValueUDInt : UDInt;   // UDInt search: value of the current possition in the array
      tempMinUDInt : UDInt;   // UDInt search: current minimum found value
      tempMaxUDInt : UDInt;   // UDInt search: current maximum found value
      tempActValueUSInt : USInt;   // USInt search: value of the current possition in the array
      tempMinUSInt : USInt;   // USInt search: current minimum found value
      tempMaxUSInt : USInt;   // USInt search: current maximum found value
      tempActValueSInt : SInt;   // SInt search: value of the current possition in the array
      tempMinSInt : SInt;   // SInt search: current minimum found value
      tempMaxSInt : SInt;   // SInt search: current maximum found value
      tempActValueReal : Real;   // Real search: value of the current possition in the array
      tempMinReal : Real;   // Real search: current minimum found value
      tempMaxReal : Real;   // Real search: current maximum found value
      tempActValueLReal : LReal;   // LReal search: value of the current possition in the array
      tempMinLReal : LReal;   // LReal search: current minimum found value
      tempMaxLReal : LReal;   // LReal search: current maximum found value
   END_VAR

   VAR CONSTANT 
      DECREMNT_BY_ONE : DInt := 1;   // Decrement by ONE as the array ends by `number of elements - 1` because the startindex is ZERO / 0
      START_FROM_SECOND_ELEMENT : Int := 1;   // The search starts from the second element of the array. The first is used for initialization of min/max
      SUBFUNCTION_NO_ERROR : Int := 0;   // Execution of subfunction finished without errors
      STATUS_NO_ERROR : Word := 16#0000;   // Execution finished without errors
      ERR_NO_ARRAY : Word := 16#8200;   // Error: At input `variableArray` the actual parameter is not an array
      ERR_WRONG_TYPE : Word := 16#8201;   // Error: The data type of the elements in the array is not supported.  Only the data types Int, UInt, DInt, UDInt, USInt, SInt and Real are supported.
      ERR_NOT_EQUAL_TYPES : Word := 16#8202;   // Error: The elements of the array do not have the same data type as the outputs `minValue` and `maxValue`
      ERR_MOVE_BLK_VARIANT : Word := 16#8203;   // Error: Subfunction `MOVE_BLK_VARIANT` executed with and error - check `subFunctionStatus` code
   END_VAR


BEGIN
	REGION Block info header
	  //=============================================================================
	  // Siemens AG / (c)Copyright 2017
	  //-----------------------------------------------------------------------------
	  // Title:            LGF_SearchMinMax
	  // Comment/Function: Searches an array for the minimum and maximum number and
	  //                   outputs the position and values of those numbers
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15 Update 2
	  // Restrictions:     ENO disabled - Error handling with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 19.08.2015  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 02.01.2017  Siemens Industry Online Support
	  //                      Upgrade: TIA Portal V14 Update 1
	  // 01.00.02 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.00.03 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.01.00 08.11.2019  Siemens Industry Presales Support
	  //                      Code refactoring, regions and more comments added
	  // 03.00.00 23.04.2020  Siemens Industry Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 09.02.2021  Simatic Systems Support
	  //                      Rework constants and comments
	  //                      Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	NOTE
	:    The status of called commands is output in `subFunctionStatus`. In this case, the output value in `status` indicates which command caused the error. In this case, refer to the TIA Portal Online Help section for information on the respective commands.
	
	---
	
	An array of any size is connected via the `variableArray` input. After a data type query in the block, the elements are copied one after the other into a variable of the appropriate type and compared. The smallest and largest values, as well as their corresponding index are output to the array.
	
	Note
	:    The following data types of the array elements are supported:  
	:    Int, DInt, UInt, UDInt, USInt, SInt, and Real.
	
	---
	
	Note
	:    If there are several identical min. or max. values, the index of the first min. or max. value is output.
	*/)
	END_REGION DESCRIPTION
	
	REGION Initialization
	  #error := false;
	  #status := #STATUS_NO_ERROR;
	  #subfunctionStatus := INT_TO_WORD(#SUBFUNCTION_NO_ERROR);
	  #tempSubfunctionErr := #SUBFUNCTION_NO_ERROR;
	END_REGION
	
	REGION Validation of inputs and outputs 
	  // Check if the variant-variable is an array if yes cout the elements of the array
	  IF NOT (IS_ARRAY(#variableArray)) THEN
	    #error := true;
	    #status := #ERR_NO_ARRAY;
	    RETURN;
	    // Check if the elements of the array and the variables min and max have the same datatype.
	  ELSIF TypeOfElements(#variableArray) <> TypeOf(#minValue) OR TypeOf(#minValue) <> TypeOf(#maxValue) THEN
	    #error := true;
	    #status := #ERR_NOT_EQUAL_TYPES;
	    RETURN;
	  ELSE
	    #tempArrayEndIndex := (UDINT_TO_DINT(CountOfElements(#variableArray)) - #DECREMNT_BY_ONE);
	  END_IF;
	  //No need for validation for array max length. It cannot exceed DInt
	END_REGION
	
	REGION Searching the array based on data type
	  CASE TypeOfElements(#variableArray) OF
	    Int:
	      REGION Search Array of Integers
	        //assign first value as min/max
	        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                COUNT := 1,
	                                                SRC_INDEX := 0,
	                                                DEST_INDEX := 0,
	                                                DEST => #tempMaxInt);
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	        
	        //Initializa Minimum value
	        #tempMinInt := #tempMaxInt;
	        //Search the Array for min/max values
	        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO
	          //Read the next element of the array
	          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                  COUNT := 1,
	                                                  SRC_INDEX := #tempCounter,
	                                                  DEST_INDEX := 0,
	                                                  DEST => #tempActValueInt);
	          // check for min
	          IF #tempActValueInt < #tempMinInt THEN
	            #tempMinInt := #tempActValueInt;
	            #tempArrayIndexMin := #tempCounter;
	            // check for max
	          ELSIF #tempActValueInt > #tempMaxInt THEN
	            #tempMaxInt := #tempActValueInt;
	            #tempArrayIndexMax := #tempCounter;
	          END_IF;
	        END_FOR;
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	      END_REGION
	      
	    UInt:
	      REGION Search Array of Usigned Integers
	        //Assign first value as min / max
	        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                COUNT := 1,
	                                                SRC_INDEX := 0,
	                                                DEST_INDEX := 0,
	                                                DEST => #tempMaxUInt);
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	        
	        //Initializa Minimum value
	        #tempMinUInt := #tempMaxUInt;
	        //Search the Array for min/max values
	        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO
	          //Read the next element of the array
	          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                  COUNT := 1,
	                                                  SRC_INDEX := #tempCounter,
	                                                  DEST_INDEX := 0,
	                                                  DEST => #tempActValueUInt);
	          // check for min
	          IF #tempActValueUInt < #tempMinUInt THEN
	            #tempMinUInt := #tempActValueUInt;
	            #tempArrayIndexMin := #tempCounter;
	            // check for max
	          ELSIF #tempActValueUInt > #tempMaxUInt THEN
	            #tempMaxUInt := #tempActValueUInt;
	            #tempArrayIndexMax := #tempCounter;
	          END_IF;
	        END_FOR;
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	      END_REGION
	      
	    DInt:
	      REGION Search Array of Double Integers
	        //Assign first value as min / max
	        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                COUNT := 1,
	                                                SRC_INDEX := 0,
	                                                DEST_INDEX := 0,
	                                                DEST => #tempMaxDInt);
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	        
	        //Initializa Minimum value
	        #tempMinDInt := #tempMaxDInt;
	        //Search the Array for min/max values
	        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO
	          //Read the next element of the array
	          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                  COUNT := 1,
	                                                  SRC_INDEX := #tempCounter,
	                                                  DEST_INDEX := 0,
	                                                  DEST => #tempActValueDInt);
	          // check for min
	          IF #tempActValueDInt < #tempMinDInt THEN
	            #tempMinDInt := #tempActValueDInt;
	            #tempArrayIndexMin := #tempCounter;
	            // check for max
	          ELSIF #tempActValueDInt > #tempMaxDInt THEN
	            #tempMaxDInt := #tempActValueDInt;
	            #tempArrayIndexMax := #tempCounter;
	          END_IF;
	        END_FOR;
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	      END_REGION
	      
	    UDInt:
	      REGION Search Array of Unsigned Double Integers
	        //Assign first value as min / max
	        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                COUNT := 1,
	                                                SRC_INDEX := 0,
	                                                DEST_INDEX := 0,
	                                                DEST => #tempMaxUDInt);
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	        
	        //Initializa Minimum value
	        #tempMinUDInt := #tempMaxUDInt;
	        //Search the Array for min/max values
	        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO
	          //Read the next element of the array
	          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                  COUNT := 1,
	                                                  SRC_INDEX := #tempCounter,
	                                                  DEST_INDEX := 0,
	                                                  DEST => #tempActValueUDInt);
	          // check for min
	          IF #tempActValueUDInt < #tempMinUDInt THEN
	            #tempMinUDInt := #tempActValueUDInt;
	            #tempArrayIndexMin := #tempCounter;
	            // check for max
	          ELSIF #tempActValueUDInt > #tempMaxUDInt THEN
	            #tempMaxUDInt := #tempActValueUDInt;
	            #tempArrayIndexMax := #tempCounter;
	          END_IF;
	        END_FOR;
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	      END_REGION
	      
	    USInt:
	      REGION Search Array of Unsigned Short Integers
	        //Assign first value as min/max
	        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                COUNT := 1,
	                                                SRC_INDEX := 0,
	                                                DEST_INDEX := 0,
	                                                DEST => #tempMaxUSInt);
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	        
	        //Initializa Minimum value
	        #tempMinUSInt := #tempMaxUSInt;
	        //Search the Array for min/max values
	        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO
	          //Read the next element of the array
	          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                  COUNT := 1,
	                                                  SRC_INDEX := #tempCounter,
	                                                  DEST_INDEX := 0,
	                                                  DEST => #tempActValueUSInt);
	          // check for min
	          IF #tempActValueUSInt < #tempMinUSInt THEN
	            #tempMinUSInt := #tempActValueUSInt;
	            #tempArrayIndexMin := #tempCounter;
	            // check for max
	          ELSIF #tempActValueUSInt > #tempMaxUSInt THEN
	            #tempMaxUSInt := #tempActValueUSInt;
	            #tempArrayIndexMax := #tempCounter;
	          END_IF;
	        END_FOR;
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	      END_REGION
	      
	    SInt:
	      REGION Search Array of Signed Integers
	        //Assign first value as min / max
	        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                COUNT := 1,
	                                                SRC_INDEX := 0,
	                                                DEST_INDEX := 0,
	                                                DEST => #tempMaxSInt);
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	        
	        //Initializa Minimum value
	        #tempMinSInt := #tempMaxSInt;
	        //Search the Array for min/max values
	        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO
	          //Read the next element of the array
	          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                  COUNT := 1,
	                                                  SRC_INDEX := #tempCounter,
	                                                  DEST_INDEX := 0,
	                                                  DEST => #tempActValueSInt);
	          // check for min
	          IF #tempActValueSInt < #tempMinSInt THEN
	            #tempMinSInt := #tempActValueSInt;
	            #tempArrayIndexMin := #tempCounter;
	            // check for max
	          ELSIF #tempActValueSInt > #tempMaxSInt THEN
	            #tempMaxSInt := #tempActValueSInt;
	            #tempArrayIndexMax := #tempCounter;
	          END_IF;
	        END_FOR;
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	      END_REGION
	      
	    Real:
	      REGION Search Array of Real
	        //Assign first value as min / max
	        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                COUNT := 1,
	                                                SRC_INDEX := 0,
	                                                DEST_INDEX := 0,
	                                                DEST => #tempMinReal);
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	        
	        //Initializa Minimum value
	        #tempMaxReal := #tempMinReal;
	        //Search the Array for min/max values
	        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO
	          
	          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                  COUNT := 1,
	                                                  SRC_INDEX := #tempCounter,
	                                                  DEST_INDEX := 0,
	                                                  DEST => #tempActValueReal);
	          // check for min
	          IF #tempActValueReal < #tempMinReal THEN
	            #tempMinReal := #tempActValueReal;
	            #tempArrayIndexMin := #tempCounter;
	            // check for max
	          ELSIF #tempActValueReal > #tempMaxReal THEN
	            #tempMaxReal := #tempActValueReal;
	            #tempArrayIndexMax := #tempCounter;
	          END_IF;
	        END_FOR;
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	      END_REGION
	      
	    LReal:
	      REGION Search Array of LReal
	        //Assign first value as min / max
	        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                COUNT := 1,
	                                                SRC_INDEX := 0,
	                                                DEST_INDEX := 0,
	                                                DEST => #tempMinLReal);
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	        
	        //Initializa Minimum value
	        #tempMaxLReal := #tempMinLReal;
	        //Search the Array for min/max values
	        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO
	          
	          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                                  COUNT := 1,
	                                                  SRC_INDEX := #tempCounter,
	                                                  DEST_INDEX := 0,
	                                                  DEST => #tempActValueLReal);
	          // check for min
	          IF #tempActValueLReal < #tempMinLReal THEN
	            #tempMinLReal := #tempActValueLReal;
	            #tempArrayIndexMin := #tempCounter;
	            // check for max
	          ELSIF #tempActValueLReal > #tempMaxLReal THEN
	            #tempMaxLReal := #tempActValueLReal;
	            #tempArrayIndexMax := #tempCounter;
	          END_IF;
	        END_FOR;
	        //Checking return value of subfunction
	        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	          #error := true;
	          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	          #status := #ERR_MOVE_BLK_VARIANT;
	          RETURN;
	        END_IF;
	      END_REGION
	      
	    ELSE
	      #error := true;
	      #subfunctionStatus := INT_TO_WORD(#SUBFUNCTION_NO_ERROR);
	      #status := #ERR_WRONG_TYPE;
	      RETURN;
	  END_CASE;
	END_REGION
	
	REGION Writing to outputs
	  //Copy found values to outputs
	  //Copy Minimum value
	  #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                          COUNT := 1,
	                                          SRC_INDEX := #tempArrayIndexMin,
	                                          DEST_INDEX := 0,
	                                          DEST => #minValue);
	  //Copy Maximum value
	  #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,
	                                          COUNT := 1,
	                                          SRC_INDEX := #tempArrayIndexMax,
	                                          DEST_INDEX := 0,
	                                          DEST => #maxValue);
	  
	  //Checking return value of subfunction
	  IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN
	    #error := true;
	    #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);
	    #status := #ERR_MOVE_BLK_VARIANT;
	    RETURN;
	  END_IF;
	  
	  //Write found indexes to outputs
	  #minValueIndex := #tempArrayIndexMin;
	  #maxValueIndex := #tempArrayIndexMax;
	  
	  //ENO mechanism is not used, nerror handling via error & status
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

