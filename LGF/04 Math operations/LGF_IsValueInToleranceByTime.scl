TYPE "LGF_typeIsValueInToleranceByTimeConfiguration"
TITLE = LGF_typeIsValueInToleranceByTimeConfiguration
VERSION : 0.1
//Module related configuration parameters 
   STRUCT
      disableLimits { S7_SetPoint := 'True'} : Bool;   // TRUE: Disable the monitoring timer. Leaving the tolerance triggers immediately
      limitsAsAbsolutValues { S7_SetPoint := 'True'} : Bool;   // TRUE: Limit given as absolut value / FALSE: Limits given as tolerance from setpoint - absolut or perecent value
      toleranzAsAbsoluteValues { S7_SetPoint := 'True'} : Bool;   // TRUE: Toleranze given as absolut value / FALSE: Toleranze in percent from Setpoint
      upperLimitMonitoringTime { S7_SetPoint := 'True'} : Time := T#10S;   // Monitoring time for the upper limit violation
      lowerLimitMonitoringTime { S7_SetPoint := 'True'} : Time := T#10S;   // Monitoring time for the lower limit violation
      setpointChangeMonitingTime { S7_SetPoint := 'True'} : Time := T#20S;   // Monitoring time for setpoint changes
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "LGF_IsValueInToleranceByTime"
TITLE = LGF_IsValueInToleranceByTime
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industries
FAMILY : LGF
NAME : LGF_IsValueInToleranceByTime
//Checks if a given value is within a specified tolerance in percent of a given set point.  
//The block has a configurable timing for set point change hiding, lower limit and as well for upper limit violation hiding.
   VAR_INPUT 
      value : Real;   // Value to check if in range of setpoint
      setpoint : Real;   // Setpoint
      lowerMinimum : Real;   // [% or ABS] Lower limit/tolerance of the setpoint in percent or absolut
      upperMaximum : Real;   // [% or ABS] Upper limit/tolerance of the setpoint in percent or absolut
      reset : Bool;   // Reset Block
      configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "LGF_typeIsValueInToleranceByTimeConfiguration";
   END_VAR

   VAR_OUTPUT 
      overHighLimit { ExternalWritable := 'False'} : Bool;   // TRUE: if value is above high limit
      belowLowLimit { ExternalWritable := 'False'} : Bool;   // TRUE: if value is below low limit
      inLimits { ExternalWritable := 'False'} : Bool;   // TRUE: if value is in between the limits
      setpointChange { ExternalWritable := 'False'} : Bool;   // TRUE: when a setpoint change has been detected
      error { ExternalWritable := 'False'} : Bool;   // Error occured
      status { ExternalWritable := 'False'} : Word;   // Status of the function
   END_VAR

   VAR 
      instMonitorUpper {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;   // Monitoringtimer, when exceeding upper tolerance limit
      instMonitorLower {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;   // Monitoringtimer, when falling below lower tolerance limit
      instMonitorChange {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;   // Monitoringtimer, when setpoint change has been detected
      statSetpointPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Setpoint in previous cycle for edge dedection
      statResetPrev { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Reset input in previous cycle for edge dedection
      statSetpointChange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Setpoint has been changed / Setpoint change monitoring active
      statWasWithinTolerance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Process value was within the tolerance set
   END_VAR

   VAR_TEMP 
      tempValueOverHighLimit : Bool;   // Value is over the high limit
      tempValueUnderLowLimit : Bool;   // Value is under the low limit
   END_VAR

   VAR CONSTANT 
      ONE : Real := 1.0;   // One / 1.0 for the procent calculation needed
      ONEHUNDRED_PERCENT : Real := 100.0;   // 100.0% Real Value
      STATUS_NO_ERROR : Word := 16#0000;   // Status: No error
      ERR_RANGE_LIMIT_VALUE_CALC : Word := 16#8401;   // Error: Wrong result during limit calculation for limit values
      ERR_SETPOINT_ABOVE_HIGH_LIMIT : Word := 16#8402;   // Error: Setpoint above absolut high limit
      ERR_SETPOINT_BELOW_LOW_LIMIT : Word := 16#8403;   // Error: Setpoint below absolut low limit
   END_VAR


BEGIN
	REGION Block info header
	  //=============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_IsValueInTolerance
	  // Comment/Function: Checks if a given value is within a specified tolerance in percent of a given set point.
	  //                   The block has a configurable timing FOR set point change hiding,
	  //                   lower limit AND as well FOR upper limit violation hiding.
	  // Library/Family:   LGF(Library of general Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V5.0
	  // Engineering:      TIA Portal V17
	  // Restrictions:     ENO disabled - error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 21.12.2023 | Siemens Industry Support
	  //                         First released version
	  //                         Copied snd extended from "IsValueInRange"
	  //=============================================================================
	END_REGION
	
	REGION DESCRIPTION
	  (/*
	The `setpoint`, `lowerMinimum` and `upperMaximum` variables define a value range.  
	The function checks whether the `value` is below, in or above the value range. The outputs `belowLowLimit`, `inLimits`, or `overHighLimit` show where the `value` is located.
	
	By the configuration it is possible to define whether the borders are given as absolute values or in percentage from set point.  
	The timing could be adjusted for set point changes and as well for hiding the violating of the lower or upper limit in case of peaks.
	
	Figure: Principle of operation
	
	![LGF_IsValueInTolerance - Principle of operation](LGF_IsValueInTolerance.PNG "LGF_IsValueInTolerance - Principle of operation")
	*/)
	END_REGION DESCRIPTION
	
	REGION Initialization and limits check
	  // Calculation of limits
	  IF #configuration.limitsAsAbsolutValues THEN
	    #tempValueOverHighLimit := #value > #upperMaximum;
	    #tempValueUnderLowLimit := #value < #lowerMinimum;
	  ELSE
	    IF #configuration.toleranzAsAbsoluteValues THEN
	      #tempValueOverHighLimit := #value > #setpoint + #upperMaximum;
	      #tempValueUnderLowLimit := #value < #setpoint - #lowerMinimum;
	    ELSE
	      #tempValueOverHighLimit := #value > (#setpoint * (#ONE + (ABS(#upperMaximum) / #ONEHUNDRED_PERCENT)));
	      #tempValueUnderLowLimit := #value < (#setpoint * (#ONE - (ABS(#lowerMinimum) / #ONEHUNDRED_PERCENT)));
	    END_IF;
	  END_IF;
	  
	  
	  // Detecting a change in the setpoint, thus resetting the was in tolerance flag
	  IF (#statSetpointPrevious <> #setpoint) THEN
	    #statWasWithinTolerance := FALSE;
	    #statSetpointChange := TRUE;
	  END_IF;
	  #statSetpointPrevious := #setpoint;
	  
	  IF FALSE
	    OR #configuration.disableLimits
	    OR (#reset AND NOT #statResetPrev)
	  THEN
	    #statWasWithinTolerance := FALSE;
	    #statSetpointChange := FALSE;
	  END_IF;
	  #statResetPrev := #reset;
	  
	  IF TRUE
	    AND NOT (#tempValueUnderLowLimit OR #tempValueOverHighLimit)
	    AND NOT #statWasWithinTolerance
	  THEN
	    #statWasWithinTolerance := TRUE;
	  END_IF;
	  
	  //Outside of data tolerance
	  IF ENO = false THEN
	    #error := true;
	    #status := #ERR_RANGE_LIMIT_VALUE_CALC;
	    #overHighLimit := false;
	    #belowLowLimit := false;
	    #inLimits := false;
	    RETURN;
	  ELSIF TRUE
	    AND #configuration.limitsAsAbsolutValues
	    AND #setpoint > #upperMaximum
	  THEN
	    #error := true;
	    #status := #ERR_SETPOINT_ABOVE_HIGH_LIMIT;
	    #overHighLimit := false;
	    #belowLowLimit := false;
	    #inLimits := false;
	    RETURN;
	  ELSIF TRUE
	    AND #configuration.limitsAsAbsolutValues
	    AND #setpoint < #lowerMinimum
	  THEN
	    #error := true;
	    #status := #ERR_SETPOINT_BELOW_LOW_LIMIT;
	    #overHighLimit := false;
	    #belowLowLimit := false;
	    #inLimits := false;
	    RETURN;
	  END_IF;
	END_REGION
	
	REGION Limits evaluation
	  // Check if the value is above the high limit
	  // In here the upper limit monitor timer will be started once the upper limit is exceeded.
	  // The signal is triggered once the timer expired and the process value is still not within the limit.
	  // This requires that the process value was at least once within the limits
	  #instMonitorUpper.TON(IN := TRUE
	                        AND #tempValueOverHighLimit
	                        AND (#statWasWithinTolerance OR #instMonitorChange.Q)
	                        AND NOT #configuration.disableLimits
	                        ,
	                        PT := #configuration.upperLimitMonitoringTime);
	  
	  // Check if the value is below the low limit
	  // As above the signal is triggered, when the lower limit is not reached within a certain time
	  #instMonitorLower.TON(IN := TRUE
	                        AND #tempValueUnderLowLimit
	                        AND (#statWasWithinTolerance OR #instMonitorChange.Q)
	                        AND NOT #configuration.disableLimits
	                        ,
	                        PT := #configuration.lowerLimitMonitoringTime);
	  
	  #instMonitorChange.TON(IN := TRUE
	                         AND #statSetpointChange
	                         AND NOT #statWasWithinTolerance
	                         AND NOT #configuration.disableLimits
	                         ,
	                         PT := #configuration.setpointChangeMonitingTime);
	  
	  IF TRUE
	    //AND #instMonitorChange.Q
	    AND #statSetpointChange
	    AND #statWasWithinTolerance
	  THEN
	    #statSetpointChange := FALSE;
	  END_IF;
	END_REGION
	
	REGION Writing to outputs
	  // Check if the value is in range and write outputs
	  #inLimits := TRUE
	  AND NOT (#instMonitorLower.Q OR #instMonitorUpper.Q)
	  AND NOT (#statSetpointChange AND NOT #instMonitorChange.Q)
	  AND #statWasWithinTolerance;
	  
	  #overHighLimit := #instMonitorUpper.Q;
	  #belowLowLimit := #instMonitorLower.Q;
	  #setpointChange := #statSetpointChange AND NOT #statWasWithinTolerance;
	  #error := FALSE;
	  #status := #STATUS_NO_ERROR;
	  // ENO mechanism is not used
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION_BLOCK

