FUNCTION_BLOCK "LGF_CosinusCI"
TITLE = LGF_CosinusCI
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Industry_Support
FAMILY : LGF
NAME : LGF_CosinusCI
//This function generates a cosinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.
   VAR_INPUT 
      amplitude : Real := 1.0;   // Amplitude of the signal profile.
      offset : Real;   // Offset of the signal profile in the Y-direction.
      periode : UDInt := 1000;   // Period duration of the signal profile in [ms]
      phaseShift : Real;   // Phase offset in [ms]
      callOB : OB_CYCLIC;   // Calling cyclic interrupt OB
      reset : Bool;   // Reset of the signal profile.
   END_VAR

   VAR_OUTPUT 
      value { ExternalWritable := 'False'} : Real;   // Current value of the cosinusoidal signal.
      error { ExternalWritable := 'False'} : Bool;   // FALSE: No error  TRUE: An error occurred during the execution of the FB
      status { ExternalWritable := 'False'} : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
      subFunctionStatus { ExternalWritable := 'False'} : Word;   // Status or return value of called FB's, FC's and system blocks
   END_VAR

   VAR 
      statRad { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // Angle in radians
      statPhaseShift { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 0.0;   // Phase shift in radians
      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // Static Counter value
   END_VAR

   VAR_TEMP 
      tempCycleTime : UDInt;   // Temp cycle time from CallOB
      tempCyclePhase : UDInt;   // Temp cycle phase from CallOB
      tempCycleStatus : Word;   // Temp cycle status from CallOB
      tempReadTimeStatus : Int;   // Temp return value of QRY_CINT
   END_VAR

   VAR CONSTANT 
      SECOND_IN_MS : UDInt := 1000;   // One second written in miliseconds. Needed in calculation in formulas
      ZERO : Int := 0;   // Numeric zero value
      SLOPE : Int := 2;   // Part of the formula
      TWO_PI : Real := 6.283185;   // 2*PI = ~6.14
      SUB_STATUS_NO_ERROR : Word := 16#0000;   // Subfunction status: No error
      STATUS_FINISHED_NO_ERROR : Word := 16#0000;   // Status: Execution finished without errors
      QRY_CINT_OB_UNAVAILABLE : Word := 16#0000;   // Cyclic interrupt status: OB not available
      ERR_OB_UNAVAILABLE : Word := 16#8600;   // Error: OB on input `callOB` is not configured / present.  Interconnect the constant name of a configured cyclic interrupt OB at the input `callOB`.
      ERR_QRY_CINT : Word := 16#8601;   // Error in `QRY_CINT` command - check `subFunctionStatus` code
   END_VAR


BEGIN
	REGION Block info header
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_CosinusCI
	  // Comment/Function: This function generates a cosinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU 1515F-2 PN FW:V2.6
	  // Engineering:      TIA Portal V15.1 Update 2
	  // Restrictions:     ENO disabled - error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 03.07.2018  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.00.02 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.00.03 26.09.2019  Simatic Systems Support
	  //                      Code refactoring, regions and more comments added
	  //                      phase shift availability added
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 15.02.2021  Simatic Systems Support
	  //                      Insert documentation
	  // 03.00.02 15.12.2023  Simatic Systems Support
	  //                      Fix callculation of 'phaseShift'
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	NOTE
	:    The status of called commands is output in `subFunctionStatus`. In this case, the output value in `status` indicates which command caused the error. In this case, refer to the TIA Portal Online Help section for information on the respective commands.
	
	---
	
	The block calculates the values for a cosinusoidal signal profile, which is output to the output parameter `value`.
	
	The `amplitude`, the `offset` in the Y-direction, the `period` (in `ms`) and the `phase shift` (in `ms`) can be set at the input parameters.
	
	The input parameter `reset` resets the signal profile. At the `value` output parameter, the value `0` is output as long as `reset` is set to `TRUE`.
	
	The block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt OB is determined in the FB with the command `QRY_CINT`. For this, the constant name of the calling cyclic interrupt OB must be interconnected at the input parameter `callOB`.
	
	![Interconnecting the cyclic interrupt OB](LGF_InterruptObAsParameter.png "Interconnecting the cyclic interrupt OB")
	
	The number of calculated values of the signal profile per period duration is calculated as follows:
	
	$$
	  Quantity Values = \frac{Period duration}{Time intervak Cyclic interrupt OB}
	$$
	
	---
	
	Note
	:    To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB should not be selected too large depending on the period duration.
	
	---
	
	------
	
	The Figure below shows the signal profile of the calculated values.
	
	![LGF_CosinusCI](LGF_CosinusCI.png "LGF_CosinusCI")
	*/)
	END_REGION DESCRIPTION
	
	REGION Get sample time
	  // get sample time, according to the cyclic interrupt OB number
	  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime,
	                                  PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);
	  
	  REGION Error handling
	    // Generate error message of the QRY_CINT function
	    IF #tempReadTimeStatus <> #ZERO THEN
	      #error := TRUE;
	      #status := #ERR_QRY_CINT;
	      #subFunctionStatus := INT_TO_WORD(#tempReadTimeStatus);
	      #value := #ZERO;
	      RETURN;
	      // Generate error message when OB unavailable
	    ELSIF (#tempCycleStatus = #QRY_CINT_OB_UNAVAILABLE) THEN
	      #error := TRUE;
	      #status := #ERR_OB_UNAVAILABLE;
	      #subFunctionStatus := #SUB_STATUS_NO_ERROR;
	      #value := 0;
	      RETURN;
	    END_IF;
	  END_REGION
	END_REGION
	
	REGION Caluclations and outputs assigment
	  IF #reset THEN
	    #statCounter := 0;
	    #value := #ZERO;
	  ELSE
	    // Increment Counter with each call of "OB_Cyclic_interrupt"
	    #statCounter += (#tempCycleTime) / #SECOND_IN_MS;
	    #statCounter := #statCounter MOD (#periode);
	    
	    // Transfer to radians
	    #statRad := UDINT_TO_REAL(#statCounter) * #TWO_PI / (UDINT_TO_REAL(#periode));
	    #statPhaseShift := (#phaseShift * #TWO_PI) / UDINT_TO_REAL(#periode);
	    
	    // Calculate output value
	    #value := COS(#statRad + #statPhaseShift) * #amplitude + #offset;
	  END_IF;
	  #error := false;
	  #status := #STATUS_FINISHED_NO_ERROR;
	  #subFunctionStatus := #SUB_STATUS_NO_ERROR;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION_BLOCK

