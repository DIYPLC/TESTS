FUNCTION "LGF_StringToDTL_ISO" : DTL
TITLE = LGF_StringToDTL_ISO
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_StringToDTL_ISO
//This function converts a character string in international format (ISO 8601) with date and time components into the data type DTL.
   VAR_INPUT 
      "date" : String;   // Date as a character string according to the format.  Example: `2019-01-22 14:07:57.696417000`.
   END_VAR

   VAR_OUTPUT 
      error : Bool;   // FALSE: No error  TRUE: An error occurred during the execution of the FB
      status : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
   END_VAR

   VAR_TEMP 
      tempIndex : DInt;   // Temp index for Nanosecond for cycle iterator
      tempDateAndTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Temp DTL variable for calculation
      tempDateString : String;   // Temp  date string to store extracted data
   END_VAR

   VAR CONSTANT 
      STATUS_FINISHED_NO_ERROR : Word := 16#0000;   // Status: Execution finished without errors
      STATUS_NO_JOB : Word := 16#7000;   // Status: No current job processed
      ERR_DATE_STRING_EMPTY : Word := 16#8400;   // Error: Input String `date` is empty
      ERR_DATE_STRING_TO_SHORT : Word := 16#8401;   // Error: Input String `date` is too short - minimum is 'YYYY-MM-DD HH:MM:SS'
      ERR_FORMAT_YEAR : Word := 16#8201;   // Error: YEAR out of range of DTL - YEAR value does not correspond to the format or specification (outside the value range of DTL)
      ERR_FORMAT_MONTH : Word := 16#8202;   // Error: MONTH out of range of DTL - MONTH value does not correspond to the format or specification (outside the value range of DTL)
      ERR_FORMAT_DAY : Word := 16#8203;   // Error: DAY out of range of DTL - DAY value does not correspond to the format or specification (outside the value range of DTL)
      ERR_FORMAT_HOUR : Word := 16#8204;   // Error: HOUR out of range of DTL - HOUR value does not correspond to the format or specification (outside the value range of DTL)
      ERR_FORMAT_MINUTE : Word := 16#8205;   // Error: MINUTE out of range of DTL - MINUTE value does not correspond to the format or specification (outside the value range of DTL)
      ERR_FORMAT_SECOND : Word := 16#8206;   // Error: SECOND out of range of DTL - SECOND value does not correspond to the format or specification (outside the value range of DTL)
      ERR_FORMAT_NANOSECOND : Word := 16#8207;   // Error: NANOSECOND out of range of DTL - NANOSECOND value does not correspond to the format or specification (outside the value range of DTL)
      INITIAL_VALUE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1970-01-01-00:00:00.0;   // Initial value of date
      CONVERT_PRECISION : USInt := 0;   // Number of decimal places
      CONVERT_FORMAT_TO_DECIMAL : Word := 16#0000;   // Output format of the characters
      CONVERT_START_POSITION : UInt := 1;   // Character position at which the result is written
      CONVERT_START_POSITION_YEAR : SInt := 1;   // Character position at which the result is written
      CONVERT_START_POSITION_MONTH : SInt := 6;   // Character position at which the result is written
      CONVERT_START_POSITION_DAY : SInt := 9;   // Character position at which the result is written
      CONVERT_START_POSITION_HOUR : SInt := 12;   // Character position at which the result is written
      CONVERT_START_POSITION_MINUTE : SInt := 15;   // Character position at which the result is written
      CONVERT_START_POSITION_SECOND : SInt := 18;   // Character position at which the result is written
      CONVERT_START_POSITION_NANOSECOND : SInt := 21;   // Character position at which the result is written
      CONVERT_SIZE_YEAR : USInt := 4;   // Number of character positions for year
      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;   // Number of character positions for month
      CONVERT_SIZE_NANOSECOND : USInt := 9;   // Number of character positions for nanoseconds
      MINIMUM_DATE_STRING_LENGTH : Int := 19;   // Minimum length of date string
      YEAR_MIN : UInt := 1970;   // Min limit for year
      YEAR_MAX : UInt := 2262;   // Max limit for year
      MONTH_MIN : USInt := 1;   // Min limit for months
      MONTH_MAX : USInt := 12;   // Max limit for months
      DAY_MIN : USInt := 1;   // Min limit for days
      DAY_MAX : USInt := 31;   // Max limit for days
      HOUR_MIN : USInt := 0;   // Min limit for hours
      HOUR_MAX : USInt := 23;   // Max limit for hours
      SECOND_MINUTE_MIN : USInt := 0;   // Min limit for seconds and minutes
      SECOND_MINUTE_MAX : USInt := 59;   // Max limit for seconds and minutes
      NANOSECOND_MIN : UDInt := 0;   // Min limit for nanoseconds
      NANOSECOND_MAX : UDInt := 999999999;   // Max limit for nanoseconds
      NANOSECOND_FOR_COUNTER : DInt := 9;   // Maximum number of caracter in nanosecond string
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_StringToDTL_ISO
	  // Comment/Function: This function converts a character string in international format
	  //                   with date components into the data type DTL.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15.1
	  // Restrictions:     ENO mechanism is not used, Error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 15.06.2016 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 02.01.2017 | Siemens Industry Online Support
	  //                         Upgrade: TIA Portal V14 Update 1
	  // 01.00.02 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.03 | 23.11.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.04 | 17.07.2019 | Simatic Systems Support
	  //                         Reworked from "LGF_StringToDTL" to "LGF_StringToDTL_ISO"
	  //                         Removed format and split into two blocks
	  //                         Bugfix - set weekday correctly
	  //                         Correction of the weekday of DTL, comments added
	  //                         Add ENO handling, adjust comments in interface
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  // 03.01.00 | 31.07.2025 | Simatic Systems Support
	  //                         Fix bug - missing error code in case of wrong date string
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	The block reads a date as a character string and converts it to the data type DTL. The individual date components in the character string are separated according to the international format (ISO 8601). The separator between the components in the character string is irrelevant.
	
	##### International format (ISO 8601):
	
	{.imagePageWidth}
	![LGF_DTLToString_ISO - Structure of the character string in accordance with ISO 8601](LGF_DTLToString_ISO.png "LGF_DTLToString_ISO - Structure of the character string in accordance with ISO 8601")
	*/)
	END_REGION DESCRIPTION
	
	REGION CONVERTER
	  IF #date = '' THEN
	    #error := TRUE;
	    #status := #ERR_DATE_STRING_EMPTY;
	    #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	    RETURN;
	  ELSIF LEN(#date) < #MINIMUM_DATE_STRING_LENGTH THEN
	    #error := TRUE;
	    #status := #ERR_DATE_STRING_TO_SHORT;
	    #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	    RETURN;
	  END_IF;
	  
	  // Set format parameters for input string
	  // International ISO 8601
	  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS
	  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--
	  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29
	  
	  REGION YEAR
	    // Separating the input string into components of DTL
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_YEAR, P := #CONVERT_START_POSITION_YEAR);
	    // Converting separated String components into DTL values
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.YEAR,
	             P      := #CONVERT_START_POSITION);
	    // Format check
	    IF (#tempDateAndTime.YEAR < #YEAR_MIN) OR (#YEAR_MAX < #tempDateAndTime.YEAR) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_YEAR;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION MONTH
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MONTH);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.MONTH,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.MONTH < #MONTH_MIN) OR (#MONTH_MAX < #tempDateAndTime.MONTH) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_MONTH;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION DAY
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_DAY);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.DAY,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.DAY < #DAY_MIN) OR (#DAY_MAX < #tempDateAndTime.DAY) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_DAY;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION HOUR
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_HOUR);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.HOUR,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.HOUR < #HOUR_MIN) OR (#HOUR_MAX < #tempDateAndTime.HOUR) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_HOUR;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION MINUTE
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MINUTE);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.MINUTE,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.MINUTE < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.MINUTE) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_MINUTE;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION SECOND
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_SECOND);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.SECOND,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.SECOND < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.SECOND) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_SECOND;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION NANOSECOND
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_NANOSECOND, P := #CONVERT_START_POSITION_NANOSECOND);
	    // Replacing of the "blan" in the nanosecond string by "0"
	    // Effect:   xx.1 --> xx.1 AND NOT xx.1 --> xx.000000001
	    FOR #tempIndex := 1 TO #NANOSECOND_FOR_COUNTER DO
	      IF #tempDateString[#tempIndex] = ' ' THEN
	        #tempDateString[#tempIndex] := '0';
	      END_IF;
	    END_FOR;
	    
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.NANOSECOND,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.NANOSECOND < 0) OR (999999999 < #tempDateAndTime.NANOSECOND) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_NANOSECOND;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  // Correction of the weekday of DTL
	  #tempDateAndTime := #tempDateAndTime + t#0ms;
	END_REGION
	
	REGION OUTPUTS
	  #LGF_StringToDTL_ISO := #tempDateAndTime;
	  #error := FALSE;
	  #status := #STATUS_FINISHED_NO_ERROR;
	  // no error handling needed because of error bit output
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

