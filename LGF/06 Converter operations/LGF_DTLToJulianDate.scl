FUNCTION "LGF_DTLToJulianDate" : Void
TITLE = LGF_DTLToJulianDate
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_DTLToJulianDate
//This function converts the date and time of data type DTL to the Julian date and as well the modified Julian Date to data type LReal (Double).  
//The timestamp is calculated based on UTC. This means that the time zone is not considered.
//
//Only times after 01/01/1990 are permitted.
   VAR_INPUT 
      timeDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Date and time as DTL to convert to Julian Date
   END_VAR

   VAR_OUTPUT 
      julianDate : LReal;   // Converted Julian date
      modifiedJulianDate : LReal;   // Converted modified Julian date
      error : Bool;   // FALSE: No error  TRUE: An error occurred during the execution of the FB
      status : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
   END_VAR

   VAR_TEMP 
      tempTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Temp value of DTL
      tempUnixTime : DInt;   // Temp result of conversion from DTL to DInt as Unix time
      tempJulianDate : LReal;   // Temp result of conversion from unix time to Julian date
      tempModifiedJulianDate : LReal;   // Temp result of conversion from unix time to modified Julian date
   END_VAR

   VAR CONSTANT 
      DELTA_1970_1990 : DInt := 631_152_000;   // Delta between 1970-1-1 and 1990-1-1 in seconds (IEC Time Base)
      SEC_PER_DAY : DInt := 86400;   // 86400 seconds in 1 day
      OFFSET_JULIAN_DATE_TO_UNIX : LReal := 2440587.5;   // Offset between Julian date and UNIX Zero time
      OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE : LReal := 2400000.5;   // Offset between modified Julian date and regular Julian Date
      TIME_ZERO_FORCE_UPDATE : Time := t#0d;   // By adding zero an update of DTL Tag is forced and auto checks are applied
      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;   // Execution finished without errors
      ERR_DTL_INPUT_VALUE_INVALID : Word := 16#8000;   // Error: Input timestamp value not valid.  The data type contains implausible data.
      ERR_TIME_BEFORE_1990 : Word := 16#8001;   // Error: Input time is before 01/01/1990. The function does not support this conversion, because of internal used datatype
      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;   // Limit of the conversion 
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Comment/Function: This function converts the date and time of data type DTL to the Julian date and as well the modified Julian Date to data type LReal (Double).  
	  //                   The timestamp is calculated based on UTC. This means that the time zone is not considered.
	  //                   Only times after 01/01/1990 are permitted.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-1516F (V2.9)
	  // Engineering:      TIA Portal V17
	  // Restrictions:     Date type (range from 01.01.1990) is used in the "Function" therefore the conversion limit is set.
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 14.04.2023 | Siemens Industry Online Support
	  //                         First released version
	  //===============================================================================
	END_REGION Block info header
	
	REGION INITIALISATION
	  #tempUnixTime := 0;
	  #tempJulianDate := 0.0;
	  #tempModifiedJulianDate := 0.0;
	END_REGION
	
	REGION CONVERT
	  // adding zero forces the PLC to update the tag and sets EON in case an error happend to the DTL value
	  #tempTimeDtl := #timeDTL + #TIME_ZERO_FORCE_UPDATE;
	  
	  IF NOT ENO THEN // Check if DTL has valid format and data
	    #julianDate := #tempJulianDate;
	    #modifiedJulianDate := #tempModifiedJulianDate;
	    #error := TRUE;
	    #status := #ERR_DTL_INPUT_VALUE_INVALID;
	    RETURN;
	  ELSIF (#tempTimeDtl < #CONVERSION_LIMIT) THEN // Check if timeUnix less than 01.01.1990
	    #julianDate := #tempJulianDate;
	    #modifiedJulianDate := #tempModifiedJulianDate;
	    #error := TRUE;
	    #status := #ERR_TIME_BEFORE_1990;
	    RETURN;
	  END_IF;
	  
	  // Convert System Time (UTC) to UNIX time
	  // DATE range D#1990-01-01 to D#2169-06-06
	  // DATE_TO_DINT conversion - The number of days since 1/1/1990 is returned as result.
	  #tempUnixTime := (DATE_TO_DINT(DTL_TO_DATE(#tempTimeDtl)) * #SEC_PER_DAY) + (TOD_TO_DINT(DTL_TO_TOD(#tempTimeDtl)) / 1000) + #DELTA_1970_1990;
	  
	  // Convert Unix time to Julian Date
	  #tempJulianDate := (DINT_TO_LREAL(#tempUnixTime) / #SEC_PER_DAY) + #OFFSET_JULIAN_DATE_TO_UNIX;
	  // Convert regular Julian date to modified Julian date
	  #tempModifiedJulianDate := #tempJulianDate - #OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE;
	END_REGION
	
	REGION OUTPUTS
	  #julianDate := #tempJulianDate;
	  #modifiedJulianDate := #tempModifiedJulianDate;
	  #error := FALSE;
	  #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	END_REGION
	
END_FUNCTION

