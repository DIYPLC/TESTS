FUNCTION "LGF_DTLToString_US" : String
TITLE = LGF_DTLToString_US
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_DTLToString_US
//This function converts a date of data type DTL into a character string of data type STRING in American format (US) (MM DD YYYY…).
   VAR_INPUT 
      "date" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Date to convert as DTL tag
      separator { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$'-$''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;   // Separator between the components of the output date.
      separatorDateAndTime { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$' $''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;   // Separator between the components date and time.
   END_VAR

   VAR_TEMP 
      tempString : String;   // Temp string to setup the date string
      tempIndex : DInt;   // Temp iterator for replacing withspaces with '0' in nanosecondstring
   END_VAR

   VAR CONSTANT 
      CONVERT_SIZE_YEAR : USInt := 4;   // Number of character positions for Year
      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;   // Number of character positions for Month, Day, Minute and Second
      CONVERT_SIZE_NANOSECOND : USInt := 9;   // Number of character positions for Nanoseconds
      CONVERT_PRECISION : USInt := 0;   // Number of decimal places to convert
      CONVERT_FORMAT_TO_STRING : Word := 16#0000;   // Output format of the characters
      CONVERT_START_POSITION_YEAR : UInt := 7;   // Character starting in string at which position the result is written.
      CONVERT_START_POSITION_MONTH : UInt := 1;   // Character starting in string at which position the result is written.
      CONVERT_START_POSITION_DAY : UInt := 4;   // Character starting in string at which position the result is written.
      CONVERT_START_POSITION_HOUR : UInt := 12;   // Character starting in string at which position the result is written.
      CONVERT_START_POSITION_MINUTE : UInt := 15;   // Character starting in string at which position the result is written.
      CONVERT_START_POSITION_SECOND : UInt := 18;   // Character starting in string at which position the result is written.
      CONVERT_START_POSITION_NANOSECOND : UInt := 21;   // Character starting in string at which position the result is written.
      SEPARATOR_POSITION_MONTH_DAY : UInt := 3;   // Character starting in string at which position the result is written.
      SEPARATOR_POSITION_DAY_YEAR : UInt := 6;   // Character starting in string at which position the result is written.
      SEPARATOR_POSITION_DATE_AND_TIME : UInt := 11;   // Character starting in string at which position the result is written.
      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;   // Character starting in string at which position the result is written.
      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;   // Character starting in string at which position the result is written.
      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;   // Character starting in string at which position the result is written.
      SEPARATOR_NANOSECOND : Char := '.';   // Seperator for Nanosecond
      SEPARATOR_TIME : Char := ':';   // Seperator for Time
      SEPARATOR_DATE : Char := '-';   // Default separator for Date
      SEPARATOR_DATE_AND_TIME : Char := ' ';   // Default separator between Date and Time
      REPLACE_NANOSECOND_COUNT : DInt := 8;   // Number of Nanosecond characters to be checked for replacing withspaces with '0'
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2025
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_DTLToString_US
	  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in American format (MM DD YYYY…).
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V17
	  // Restrictions:     ENO mechanism is not used, no error handling
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 28.07.2025 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 09.10.2025 | Simatic Systems Support
	  //                         Spelling errors
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	The block reads a date of data type DTL and converts the individual components of the date (year, month, day, hour…) into a character string and outputs it in American format (US). The separator between the components of the date is variable.
	
	##### American format (US):
	
	{.imagePageWidth}
	![LGF_DTLToString_US - Structure of the character string in accordance with American format](LGF_DTLToString_US.png "LGF_DTLToString_US - Structure of the character string in accordance with American format")
	    
	##### Separator:
	    
	At the input parameter `separator`, you specify the separator between the components of the date, at `seperatorDateAndTime` you specify the separator between the date and the time.
	    
	##### Example:
	    
	* separatorDate = `-` - outString = `06-20-2025…` (default)
	* separatorDate = `/` - outString = `06/20/2025…`
	
	* separatorDateAndTime = ` ` - outString = `06-20-2025 12:45…` (default)
	* separatorDateAndTime = `T` - outString = `06-20-2025T12:45…`
	*/)
	END_REGION DESCRIPTION
	
	REGION INITIALISATION
	  #tempString := '';
	END_REGION
	
	REGION CONVERTER
	  // Set format parameters for output string
	  // American format
	  // DTL  | M| M| -| D| D| -| Y| Y| Y| Y|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS
	  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--
	  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29
	  
	  // Convert "Value" into "String" and place at the right position
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.YEAR,
	           P      := #CONVERT_START_POSITION_YEAR,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_YEAR,
	           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.MONTH,
	           P      := #CONVERT_START_POSITION_MONTH,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.DAY,
	           P      := #CONVERT_START_POSITION_DAY,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.HOUR,
	           P      := #CONVERT_START_POSITION_HOUR,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.MINUTE,
	           P      := #CONVERT_START_POSITION_MINUTE,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.SECOND,
	           P      := #CONVERT_START_POSITION_SECOND,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.NANOSECOND,
	           P      := #CONVERT_START_POSITION_NANOSECOND,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_NANOSECOND,
	           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond
	  
	  // Place separators at the right position in the string
	  IF #separator = '$00' THEN
	    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;
	    #tempString[#SEPARATOR_POSITION_DAY_YEAR] := #SEPARATOR_DATE;
	  ELSE
	    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;
	    #tempString[#SEPARATOR_POSITION_DAY_YEAR] := #separator;
	  END_IF;
	  
	  IF #separatorDateAndTime = '$00' THEN
	    #tempString[#SEPARATOR_POSITION_DATE_AND_TIME] := #SEPARATOR_DATE_AND_TIME;
	  ELSE
	    #tempString[#SEPARATOR_POSITION_DATE_AND_TIME] := #separatorDateAndTime;
	  END_IF;
	  
	  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;
	  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;
	  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;
	  
	  // Correcting the string, due to the conversion of a leading "0" value into a "blank".
	  // Replacing of "blank" by "0"
	  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_MONTH] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_DAY] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_HOUR] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_SECOND] := '0';
	  END_IF;
	  
	  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO
	    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN
	      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';
	    ELSE
	      EXIT;
	    END_IF;
	  END_FOR;
	END_REGION
	
	REGION OUTPUTS
	  #LGF_DTLToString_US := #tempString;
	  // no error handling needed
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

