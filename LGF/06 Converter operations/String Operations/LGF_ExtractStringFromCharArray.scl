FUNCTION "LGF_ExtractStringFromCharArray" : Word
TITLE = LGF_ExtractStringFromCharArray
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'Siemens Online Support'
FAMILY : LGF
NAME : LGF_ExtractStringFromCharArray
//The function extracts a String specified by a text before and after from an array of characters.
   VAR_INPUT 
      textBefore : String;   // Text in front of the characters which has to be extracted
      textAfter : String;   // Text behind the characters which has to be extracted
   END_VAR

   VAR_OUTPUT 
      extractedString : String;   // Extracted string
      status : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
   END_VAR

   VAR_IN_OUT 
      searchIn : Variant;   // Array of Character or Byte to search in
   END_VAR

   VAR_TEMP 
      tempNumElements : UDInt;   // Number of elements in given array
      tempPosInArray : DInt;   // Position in array during search
      tempLenTextBefore : Int;   // Length of text before
      tempPosTextBefore : DInt;   // Position of text before in array of Char
      tempLenTextAfter : Int;   // Length of text after
      tempPosTextAfter : Int;   // Position of text after in converted string
      tempString : String;   // Temporary string to work with
   END_VAR

   VAR CONSTANT 
      LEN_STRING : UInt := 254;   // Max. length of String
      STATUS_TEXT_FOUND : Word := 16#0000;   // Successful, start text and end text were found
      WARNING_ONLY_START : Word := 16#9001;   // Unsuccessful, only start text was found, extracted String is filled with characters after start text
      WARNING_NOTHING_FOUND : Word := 16#9002;   // Unsuccessful, neither text was found
      STATUS_NO_ERROR : Word := 16#0000;   // Status: Execution finished without errors
      ERR_NO_ARRAY : Word := 16#8200;   // Error: No array of Char or Byte is present at the input `searchIn`
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS / (c)Copyright 2021
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_ExtractStringFromCharArray
	  // Function:         The function extracts a String specified by a text before and after
	  //                   from an array of characters.
	  // Library:          LGF
	  // Author:           Siemens Industry Online Support
	  // Tested with:      CPU 1516-3 PN/DP
	  // Engineering:      TIA Portal V17
	  // Restrictions:     --
	  // Requirements:     S7-1200/1500
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 01.04.2019 | Siemens Online Support | First released version (LHttp)
	  // 01.01.00 | 10.06.2022 | Siemens Online Support | Adaption and integration into LGF
	  //===============================================================================
	END_REGION
	
	REGION Initialization
	  #tempPosTextBefore := 0;
	  #tempPosTextAfter := 0;
	  #tempPosInArray := 0;
	  #tempLenTextBefore := LEN(#textBefore);
	  #tempLenTextAfter := LEN(#textAfter);
	  #extractedString := '';
	  #status := #STATUS_NO_ERROR;
	  #LGF_ExtractStringFromCharArray := #WARNING_NOTHING_FOUND;
	  
	  REGION Validation of inputs
	    // check whether the input is an ARRAY and TYPE of elements is CHAR or BYTE
	    // IF so, the number OF the ARRAY elements is read out.
	    // IF it is NOT an ARRAY, the program execution is terminated at this point
	    IF TRUE
	      AND IS_ARRAY(#searchIn)
	      AND ((TypeOfElements(#searchIn) = Char) OR (TypeOfElements(#searchIn) = Byte))
	    THEN
	      // Get number of elements
	      #tempNumElements := CountOfElements(#searchIn);
	    ELSE
	      #status := #ERR_NO_ARRAY;
	      RETURN;
	    END_IF;
	  END_REGION Validation of inputs
	END_REGION Initialization
	
	REGION Process
	  REPEAT // Search for text before until something was found
	    // Convert Chars to String
	    Chars_TO_Strg(Chars  := #searchIn,
	                  pChars := #tempPosInArray, // Subtract offset since pChars is zero based
	                  Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),
	                  Strg   => #tempString);
	    
	    // Search for text before
	    #tempPosTextBefore := FIND(IN1 := #tempString, IN2 := #textBefore);
	    
	    // Text before was found
	    IF #tempPosTextBefore > 0 THEN
	      // Set position in array to end of text before
	      #tempPosInArray += #tempPosTextBefore + #tempLenTextBefore - 1;
	      
	      // Create new string from end of text before
	      Chars_TO_Strg(Chars  := #searchIn,
	                    pChars := #tempPosInArray, // Subtract offset since pChars is zero based
	                    Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),
	                    Strg   => #tempString);
	      
	      // Find end of string to be extracted
	      #tempPosTextAfter := FIND(IN1 := #tempString, IN2 := #textAfter);
	      
	      IF #tempPosTextAfter > 0 THEN // Shorten string if text after was found
	        #extractedString := LEFT(IN := #tempString, L := #tempPosTextAfter - 1);
	        #LGF_ExtractStringFromCharArray := #STATUS_TEXT_FOUND;
	        EXIT;
	        
	      ELSE // Output whole string if text after was not found
	        #extractedString := #tempString;
	        #LGF_ExtractStringFromCharArray := #WARNING_ONLY_START;
	        EXIT;
	      END_IF;
	      
	    ELSE
	      // Otherwise continue search in next string minus length of text before to ensure
	      // keywords are not broken up at the end of a string and thus missed
	      #tempPosInArray += UINT_TO_INT(#LEN_STRING) - #tempLenTextBefore;
	    END_IF;
	    
	    // Repeat until end of array is reached
	  UNTIL (#tempPosInArray > #tempNumElements) END_REPEAT;
	END_REGION Process
	
END_FUNCTION

